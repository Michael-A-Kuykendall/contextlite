
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>pipeline: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">contextlite/internal/pipeline/assembly.go (60.9%)</option>
				
				<option value="file1">contextlite/internal/pipeline/timing.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package pipeline

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "time"

        "contextlite/pkg/config"
        "contextlite/pkg/types"
)

// CacheParts contains all components for building a cache key
type CacheParts struct {
        QueryHash           string `json:"query_hash"`
        CorpusHash          string `json:"corpus_hash"`
        ModelID             string `json:"model_id"`
        TokenizerVersion    string `json:"tokenizer_version"`
        TokenizerVocabHash  string `json:"tokenizer_vocab_hash"`
        WeightsHash         string `json:"weights_hash"`
        ConceptDFVersion    string `json:"concept_df_version"`
        MaxTokens           int    `json:"max_tokens"`
        MaxDocuments        int    `json:"max_documents"`
        ObjectiveStyle      string `json:"objective_style"`
}

// BuildCacheKey creates a deterministic cache key from parts
func BuildCacheKey(parts CacheParts) string <span class="cov8" title="1">{
        jsonData, _ := json.Marshal(parts)
        hash := sha256.Sum256(jsonData)
        return hex.EncodeToString(hash[:])
}</span>

// Pipeline provides the main context assembly pipeline
// This is now a thin wrapper that delegates to the engine
type Pipeline struct {
        storage types.StorageInterface
        engine  types.ContextEngine
        config  *config.Config
}

// New creates a new pipeline instance
func New(storage types.StorageInterface, engine types.ContextEngine, config *config.Config) *Pipeline <span class="cov8" title="1">{
        return &amp;Pipeline{
                storage: storage,
                engine:  engine,
                config:  config,
        }
}</span>

// Getter methods for testing
func (p *Pipeline) Storage() types.StorageInterface <span class="cov8" title="1">{
        return p.storage
}</span>

func (p *Pipeline) Config() *config.Config <span class="cov8" title="1">{
        return p.config
}</span>

// AssembleContext performs the complete context assembly pipeline
// This now simply delegates to the engine and handles type conversion
func (p *Pipeline) AssembleContext(ctx context.Context, req *types.AssembleRequest) (*types.QueryResult, error) <span class="cov8" title="1">{
        // Check cache first if enabled
        var cacheKey string
        if req.UseCache </span><span class="cov8" title="1">{
                cacheKey = p.buildCacheKey(ctx, req)
                if cached, err := p.getCachedResultByKey(ctx, cacheKey); err == nil &amp;&amp; cached != nil </span><span class="cov0" title="0">{
                        cached.CacheHit = true
                        cached.CacheKey = cacheKey
                        return cached, nil
                }</span>
        }

        // Convert AssembleRequest to ContextRequest for the engine
        <span class="cov8" title="1">contextReq := types.ContextRequest{
                Query:         req.Query,
                MaxTokens:     req.MaxTokens,
                MaxDocuments:  req.MaxDocuments,
                WorkspacePath: req.WorkspacePath,
        }
        
        // Delegate ALL the work to the engine
        startTime := time.Now()
        result, err := p.engine.AssembleContext(ctx, contextReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Convert ContextResult to QueryResult for backward compatibility
        <span class="cov8" title="1">queryResult := &amp;types.QueryResult{
                Query:          req.Query,
                Documents:      result.Documents,
                TotalDocuments: len(result.Documents),
                TotalTokens:    result.TotalTokens,
                CoherenceScore: result.CoherenceScore,
                CacheHit:       result.CacheHit,
                CacheKey:       cacheKey,
        }
        
        // Convert optimizationResult to optimizationMetrics if present
        if result.optimizationMetrics != nil </span><span class="cov0" title="0">{
                queryResult.optimizationMetrics = types.optimizationMetrics{
                        SolverUsed:      result.optimizationMetrics.SolverUsed,
                        optimizerStatus:        result.optimizationMetrics.optimizerStatus,
                        Objective:       int64(result.optimizationMetrics.Objective),
                        SolveTimeUs:     result.optimizationMetrics.SolveTimeUs,
                        SolveTimeMs:     float64(result.optimizationMetrics.SolveTimeUs) / 1000.0,
                        VariableCount:   result.optimizationMetrics.VariableCount,
                        ConstraintCount: result.optimizationMetrics.ConstraintCount,
                        KCandidates:     result.optimizationMetrics.KCandidates,
                        PairsCount:      result.optimizationMetrics.PairsCount,
                        BudgetTokens:    result.optimizationMetrics.BudgetTokens,
                        MaxDocs:         result.optimizationMetrics.MaxDocs,
                        FallbackReason:  result.optimizationMetrics.FallbackReason,
                }
        }</span>
        
        // Add timing information
        <span class="cov8" title="1">totalTime := time.Since(startTime)
        queryResult.Timings = types.StageTimings{
                TotalUs: totalTime.Microseconds(),
                TotalMs: float64(totalTime.Microseconds()) / 1000.0,
                // Other timing fields come from the engine if it provides them
        }
        
        // Cache result if enabled and high quality
        if req.UseCache &amp;&amp; queryResult.CoherenceScore &gt; 0.5 </span><span class="cov0" title="0">{
                p.cacheResult(ctx, req, queryResult)
        }</span>
        
        <span class="cov8" title="1">return queryResult, nil</span>
}

// IndexDocument delegates to the engine
func (p *Pipeline) IndexDocument(doc types.Document) error <span class="cov8" title="1">{
        return p.engine.IndexDocument(doc)
}</span>

// RemoveDocument delegates to the engine
func (p *Pipeline) RemoveDocument(docID string) error <span class="cov8" title="1">{
        return p.engine.RemoveDocument(docID)
}</span>

// GetEngineStats delegates to the engine
func (p *Pipeline) GetEngineStats() (*types.EngineStats, error) <span class="cov8" title="1">{
        return p.engine.GetStats()
}</span>

// UpdateEngineConfig delegates to the engine
func (p *Pipeline) UpdateEngineConfig(config types.EngineConfig) error <span class="cov8" title="1">{
        return p.engine.UpdateConfig(config)
}</span>

// Close performs cleanup
func (p *Pipeline) Close() error <span class="cov8" title="1">{
        if err := p.engine.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if p.storage != nil </span><span class="cov8" title="1">{
                return p.storage.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Cache management helpers (these stay in pipeline as they're not core to engine)

// buildCacheKey generates a deterministic cache key for the request
func (p *Pipeline) buildCacheKey(ctx context.Context, req *types.AssembleRequest) string <span class="cov8" title="1">{
        // Get corpus hash
        corpusHash, _ := p.storage.GetCorpusHash(ctx)
        
        // Build query hash
        queryHash := p.hashQuery(req)
        
        // Get tokenizer version from config
        tokenizerVersion := "v1.0"
        if p.config != nil &amp;&amp; p.config.Tokenizer.ModelID != "" </span><span class="cov8" title="1">{
                tokenizerVersion = p.config.Tokenizer.ModelID + "-v1.0"
        }</span>
        
        // Compute weights hash from workspace weights
        <span class="cov8" title="1">weightsHash := "default"
        if req.WorkspacePath != "" </span><span class="cov8" title="1">{
                if weights, err := p.storage.GetWorkspaceWeights(ctx, req.WorkspacePath); err == nil </span><span class="cov0" title="0">{
                        weightsData, _ := json.Marshal(weights)
                        hash := sha256.Sum256(weightsData)
                        weightsHash = hex.EncodeToString(hash[:8]) // First 8 bytes
                }</span>
        }
        
        // Build cache parts
        <span class="cov8" title="1">parts := CacheParts{
                QueryHash:           queryHash,
                CorpusHash:          corpusHash,
                ModelID:             req.ModelID,
                TokenizerVersion:    tokenizerVersion,
                TokenizerVocabHash:  "vocab-" + tokenizerVersion,
                WeightsHash:         weightsHash,
                ConceptDFVersion:    "concepts-v1.0",
                MaxTokens:           req.MaxTokens,
                MaxDocuments:        req.MaxDocuments,
                ObjectiveStyle:      req.ObjectiveStyle,
        }
        
        return BuildCacheKey(parts)</span>
}

// getCachedResultByKey retrieves cached result by cache key
func (p *Pipeline) getCachedResultByKey(ctx context.Context, cacheKey string) (*types.QueryResult, error) <span class="cov8" title="1">{
        return p.storage.GetCachedResultByKey(ctx, cacheKey)
}</span>

// cacheResult saves query result to cache
func (p *Pipeline) cacheResult(ctx context.Context, req *types.AssembleRequest, result *types.QueryResult) <span class="cov0" title="0">{
        queryHash := p.hashQuery(req)
        corpusHash, err := p.storage.GetCorpusHash(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">modelID := req.ModelID
        if modelID == "" &amp;&amp; p.config != nil </span><span class="cov0" title="0">{
                modelID = p.config.Tokenizer.ModelID
        }</span>
        
        <span class="cov0" title="0">tokenizerVersion := "1.0"
        
        // Cache for configured TTL
        ttl := time.Duration(req.CacheTTL) * time.Minute
        if ttl &lt;= 0 &amp;&amp; p.config != nil </span><span class="cov0" title="0">{
                ttl = time.Duration(p.config.Cache.L2TTLMinutes) * time.Minute
        }</span>
        <span class="cov0" title="0">if ttl &lt;= 0 </span><span class="cov0" title="0">{
                ttl = 24 * time.Hour // Default 24 hours
        }</span>
        <span class="cov0" title="0">expiresAt := time.Now().Add(ttl)
        
        // Use the new method with cache key
        cacheKey := result.CacheKey
        p.storage.SaveQueryCacheWithKey(ctx, queryHash, corpusHash, modelID, tokenizerVersion, cacheKey, result, expiresAt)</span>
}

// hashQuery generates a hash for the query request
func (p *Pipeline) hashQuery(req *types.AssembleRequest) string <span class="cov8" title="1">{
        // Create deterministic hash of query parameters
        data := struct {
                Query           string   `json:"query"`
                MaxTokens       int      `json:"max_tokens"`
                MaxDocuments    int      `json:"max_documents"`
                WorkspacePath   string   `json:"workspace_path"`
                IncludePatterns []string `json:"include_patterns"`
                ExcludePatterns []string `json:"exclude_patterns"`
                ObjectiveStyle  string   `json:"objective_style"`
        }{
                Query:           req.Query,
                MaxTokens:       req.MaxTokens,
                MaxDocuments:    req.MaxDocuments,
                WorkspacePath:   req.WorkspacePath,
                IncludePatterns: req.IncludePatterns,
                ExcludePatterns: req.ExcludePatterns,
                ObjectiveStyle:  req.ObjectiveStyle,
        }
        
        jsonData, _ := json.Marshal(data)
        hash := sha256.Sum256(jsonData)
        return hex.EncodeToString(hash[:])
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package pipeline provides timing utilities for performance measurement
package pipeline

import "time"

// T represents a timing measurement starting point
type T struct {
        t0 time.Time
}

// Start creates a new timing measurement starting at the current time
func Start() T <span class="cov8" title="1">{
        return T{t0: time.Now()} // monotonic clock included
}</span>

// Us returns the elapsed time in microseconds since Start()
func (t T) Us() int64 <span class="cov8" title="1">{
        return time.Since(t.t0).Nanoseconds() / 1_000
}</span>

// Ms returns the elapsed time in milliseconds as a float64 since Start()
func (t T) Ms() float64 <span class="cov8" title="1">{
        return float64(t.Us()) / 1_000.0
}</span>

// Ns returns the elapsed time in nanoseconds since Start()
func (t T) Ns() int64 <span class="cov8" title="1">{
        return time.Since(t.t0).Nanoseconds()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
