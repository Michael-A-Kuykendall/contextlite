
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>license: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">contextlite/internal/license/license.go (81.2%)</option>
				
				<option value="file1">contextlite/internal/license/tracked.go (72.2%)</option>
				
				<option value="file2">contextlite/internal/license/tracking.go (84.4%)</option>
				
				<option value="file3">contextlite/internal/license/trial.go (71.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package license

import (
        "crypto"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/x509"
        "encoding/base64"
        "encoding/json"
        "encoding/pem"
        "fmt"
        mathrand "math/rand"
        "net"
        "os"
        "path/filepath"
        "runtime"
        "time"

        "github.com/denisbrodbeck/machineid"
)

// LicenseTier represents the license level
type LicenseTier string

const (
        TierDeveloper  LicenseTier = "developer"
        TierPro        LicenseTier = "professional"
        TierEnterprise LicenseTier = "enterprise"
)

// License represents a software license
type License struct {
        Key          string      `json:"key"`
        Email        string      `json:"email"`
        Tier         LicenseTier `json:"tier"`
        IssuedAt     time.Time   `json:"issued_at"`
        ExpiresAt    *time.Time  `json:"expires_at,omitempty"` // nil for perpetual
        MaxDocuments int         `json:"max_documents"`
        MaxUsers     int         `json:"max_users"`
        Features     []string    `json:"features"`
        HardwareID   string      `json:"hardware_id"`
        Signature    string      `json:"signature"`
}

// LicenseManager handles license validation and enforcement
type LicenseManager struct {
        publicKey  *rsa.PublicKey
        license    *License
        lastCheck  time.Time
        gracePeriod time.Duration
}

// NewLicenseManager creates a new license manager
func NewLicenseManager() *LicenseManager <span class="cov8" title="1">{
        return &amp;LicenseManager{
                publicKey:   getPublicKey(),
                gracePeriod: 14 * 24 * time.Hour, // 14 days
        }
}</span>

// LoadLicense loads and validates a license from file
func (lm *LicenseManager) LoadLicense(licensePath string) error <span class="cov8" title="1">{
        data, err := os.ReadFile(licensePath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read license file: %w", err)
        }</span>

        <span class="cov8" title="1">var license License
        if err := json.Unmarshal(data, &amp;license); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to parse license: %w", err)
        }</span>

        <span class="cov8" title="1">if err := lm.validateLicense(&amp;license); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("license validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">lm.license = &amp;license
        lm.lastCheck = time.Now()
        return nil</span>
}

// validateLicense performs comprehensive license validation
func (lm *LicenseManager) validateLicense(license *License) error <span class="cov8" title="1">{
        // 1. Verify signature
        if err := lm.verifySignature(license); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("signature verification failed: %w", err)
        }</span>

        // 2. Check hardware binding
        <span class="cov0" title="0">currentHW, err := getHardwareFingerprint()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get hardware fingerprint: %w", err)
        }</span>

        <span class="cov0" title="0">if license.HardwareID != "" &amp;&amp; license.HardwareID != currentHW </span><span class="cov0" title="0">{
                return fmt.Errorf("license is bound to different hardware")
        }</span>

        // 3. Check expiration
        <span class="cov0" title="0">if license.ExpiresAt != nil &amp;&amp; time.Now().After(*license.ExpiresAt) </span><span class="cov0" title="0">{
                return fmt.Errorf("license has expired")
        }</span>

        // 4. Validate tier-specific limits
        <span class="cov0" title="0">if err := lm.validateTierLimits(license); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("tier validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// verifySignature verifies the license signature
func (lm *LicenseManager) verifySignature(license *License) error <span class="cov8" title="1">{
        // Create verification payload (excluding signature)
        payload := fmt.Sprintf("%s:%s:%s:%d:%d:%d:%s",
                license.Key, license.Email, license.Tier,
                license.IssuedAt.Unix(), license.MaxDocuments,
                license.MaxUsers, license.HardwareID)

        // Decode signature
        signature, err := base64.StdEncoding.DecodeString(license.Signature)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid signature encoding: %w", err)
        }</span>

        // Hash payload
        <span class="cov8" title="1">hash := sha256.Sum256([]byte(payload))

        // Verify signature
        err = rsa.VerifyPKCS1v15(lm.publicKey, crypto.SHA256, hash[:], signature)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("signature verification failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateTierLimits enforces tier-specific limitations
func (lm *LicenseManager) validateTierLimits(license *License) error <span class="cov8" title="1">{
        switch license.Tier </span>{
        case TierDeveloper:<span class="cov8" title="1">
                if license.MaxDocuments &gt; 10000 </span><span class="cov8" title="1">{
                        return fmt.Errorf("developer tier limited to 10,000 documents")
                }</span>
                <span class="cov8" title="1">if license.MaxUsers &gt; 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf("developer tier limited to single user")
                }</span>
        case TierPro:<span class="cov8" title="1">
                if license.MaxDocuments &gt; 0 &amp;&amp; license.MaxDocuments &lt; 10001 </span><span class="cov8" title="1">{
                        return fmt.Errorf("professional tier requires unlimited documents")
                }</span>
                <span class="cov8" title="1">if license.MaxUsers &gt; 10 </span><span class="cov8" title="1">{
                        return fmt.Errorf("professional tier limited to 10 users")
                }</span>
        case TierEnterprise:<span class="cov8" title="1"></span>
                // Enterprise has no limits
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown license tier: %s", license.Tier)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetFeatures returns available features for current license
func (lm *LicenseManager) GetFeatures() []string <span class="cov8" title="1">{
        if lm.license == nil </span><span class="cov8" title="1">{
                return getDeveloperFeatures()
        }</span>

        <span class="cov8" title="1">switch lm.license.Tier </span>{
        case TierDeveloper:<span class="cov8" title="1">
                return getDeveloperFeatures()</span>
        case TierPro:<span class="cov8" title="1">
                return getProFeatures()</span>
        case TierEnterprise:<span class="cov8" title="1">
                return getEnterpriseFeatures()</span>
        default:<span class="cov8" title="1">
                return getDeveloperFeatures()</span>
        }
}

// HasFeature checks if a specific feature is available
func (lm *LicenseManager) HasFeature(feature string) bool <span class="cov8" title="1">{
        features := lm.GetFeatures()
        for _, f := range features </span><span class="cov8" title="1">{
                if f == feature </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsInGracePeriod checks if we're in the grace period for unlicensed usage
func (lm *LicenseManager) IsInGracePeriod() bool <span class="cov8" title="1">{
        if lm.license != nil </span><span class="cov8" title="1">{
                return false // Licensed, no grace period needed
        }</span>

        // Check if first run file exists
        <span class="cov8" title="1">firstRunPath := getFirstRunPath()
        if _, err := os.Stat(firstRunPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Create first run marker
                os.WriteFile(firstRunPath, []byte(time.Now().Format(time.RFC3339)), 0644)
                return true
        }</span>

        // Read first run time
        <span class="cov8" title="1">data, err := os.ReadFile(firstRunPath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">firstRun, err := time.Parse(time.RFC3339, string(data))
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return time.Since(firstRun) &lt; lm.gracePeriod</span>
}

// GetMaxDocuments returns document limit for current license
func (lm *LicenseManager) GetMaxDocuments() int <span class="cov8" title="1">{
        if lm.license == nil </span><span class="cov8" title="1">{
                if lm.IsInGracePeriod() </span><span class="cov8" title="1">{
                        return 10000 // Grace period allows developer limits
                }</span>
                <span class="cov0" title="0">return 1000</span> // Unlicensed severely limited
        }
        <span class="cov8" title="1">return lm.license.MaxDocuments</span>
}

// GetTier returns the current license tier
func (lm *LicenseManager) GetTier() LicenseTier <span class="cov8" title="1">{
        if lm.license == nil </span><span class="cov8" title="1">{
                if lm.IsInGracePeriod() </span><span class="cov8" title="1">{
                        return TierDeveloper // Grace period gets developer features
                }</span>
                <span class="cov0" title="0">return TierDeveloper</span> // Default to most restrictive
        }
        <span class="cov8" title="1">return lm.license.Tier</span>
}

// Feature definitions
func getDeveloperFeatures() []string <span class="cov8" title="1">{
        return []string{
                "basic_search",
                "rest_api",
                "sqlite_storage",
                "single_workspace",
        }
}</span>

func getProFeatures() []string <span class="cov8" title="1">{
        features := getDeveloperFeatures()
        return append(features,
                "unlimited_workspaces",
                "advanced_smt",
                "7d_scoring",
                "caching",
                "priority_support",
        )
}</span>

func getEnterpriseFeatures() []string <span class="cov8" title="1">{
        features := getProFeatures()
        return append(features,
                "multi_tenant",
                "sso_ldap",
                "custom_mcp",
                "white_label",
                "source_access",
                "sla_support",
                "custom_integrations",
                "team_deployment",
                "on_premise",
                "analytics",
                "audit_trails",
                "compliance_reporting",
        )
}</span>

// Hardware fingerprinting
func getHardwareFingerprint() (string, error) <span class="cov8" title="1">{
        // Get machine ID (cross-platform)
        machineID, err := machineid.ID()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Get additional hardware info
        <span class="cov8" title="1">hostname, _ := os.Hostname()
        
        // Get primary network interface MAC
        interfaces, err := net.Interfaces()
        var mac string
        if err == nil </span><span class="cov8" title="1">{
                for _, iface := range interfaces </span><span class="cov8" title="1">{
                        if iface.Flags&amp;net.FlagUp != 0 &amp;&amp; iface.Flags&amp;net.FlagLoopback == 0 </span><span class="cov8" title="1">{
                                mac = iface.HardwareAddr.String()
                                break</span>
                        }
                }
        }

        // Combine for fingerprint
        <span class="cov8" title="1">combined := fmt.Sprintf("%s:%s:%s:%s", machineID, hostname, mac, runtime.GOOS)
        hash := sha256.Sum256([]byte(combined))
        return base64.StdEncoding.EncodeToString(hash[:]), nil</span>
}

func getFirstRunPath() string <span class="cov8" title="1">{
        homeDir, _ := os.UserHomeDir()
        return fmt.Sprintf("%s/.contextlite_first_run", homeDir)
}</span>

// Embedded public key for license verification
func getPublicKey() *rsa.PublicKey <span class="cov8" title="1">{
        // Production RSA public key for license verification
pubKeyPEM := `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzoehpns722oiWSXLiVMd
Q412F/nO5EIraHXlbcPI7nF0BLu4F7TNP4U5qUhOkIjQr50OWvBQoxw8Nn7HfYdR
HJAmPmLJn7FLiNz+AuFw9+c8vVjmkfqTt1cmGjZ7Tzb0sFJTzCH4l86MYsh5/Rc0
5RhOJ08yql6jSLYs/GeWhh0CgWRvmd1ZMpfZcwPAslcG4JP6hY0pOiO6/dLwoxOV
17R+FR7/CDGHiYCLJ4jk7yVHAF9NBrZu4KpxzP6Dn8fhrArRnyOhaJaXLFDGD36w
pPm32QZ1R6AQjnPFHBL3qGCznguNUvkWCLTYN15BXU90A87cMufYMAAdjERAveps
FQIDAQAB
-----END PUBLIC KEY-----`

        block, _ := pem.Decode([]byte(pubKeyPEM))
        if block == nil </span><span class="cov0" title="0">{
                panic("failed to parse public key PEM")</span>
        }

        <span class="cov8" title="1">pub, err := x509.ParsePKIXPublicKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to parse public key: %v", err))</span>
        }

        <span class="cov8" title="1">return pub.(*rsa.PublicKey)</span>
}

// License generation (for your license server)
func GenerateBasicLicense(email string, tier LicenseTier, hardwareID string, privateKey *rsa.PrivateKey) (*License, error) <span class="cov8" title="1">{
        license := &amp;License{
                Key:          generateLicenseKey(),
                Email:        email,
                Tier:         tier,
                IssuedAt:     time.Now(),
                HardwareID:   hardwareID,
        }

        // Set tier-specific limits
        switch tier </span>{
        case TierDeveloper:<span class="cov8" title="1">
                license.MaxDocuments = 10000
                license.MaxUsers = 1
                license.Features = getDeveloperFeatures()</span>
        case TierPro:<span class="cov8" title="1">
                license.MaxDocuments = 0 // 0 = unlimited
                license.MaxUsers = 10
                license.Features = getProFeatures()</span>
        case TierEnterprise:<span class="cov8" title="1">
                license.MaxDocuments = 0 // unlimited
                license.MaxUsers = 0 // unlimited
                license.Features = getEnterpriseFeatures()</span>
        }

        // Generate signature
        <span class="cov8" title="1">payload := fmt.Sprintf("%s:%s:%s:%d:%d:%d:%s",
                license.Key, license.Email, license.Tier,
                license.IssuedAt.Unix(), license.MaxDocuments,
                license.MaxUsers, license.HardwareID)

        hash := sha256.Sum256([]byte(payload))
        signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hash[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign license: %w", err)
        }</span>

        <span class="cov8" title="1">license.Signature = base64.StdEncoding.EncodeToString(signature)
        return license, nil</span>
}

func generateLicenseKey() string <span class="cov8" title="1">{
        // Generate a readable license key (XXXX-XXXX-XXXX-XXXX format)
        chars := "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        key := make([]byte, 19) // 16 chars + 3 dashes
        
        for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; 4; j++ </span><span class="cov8" title="1">{
                        key[i*5+j] = chars[mathrand.Intn(len(chars))]
                }</span>
                <span class="cov8" title="1">if i &lt; 3 </span><span class="cov8" title="1">{
                        key[i*5+4] = '-'
                }</span>
        }
        
        <span class="cov8" title="1">return string(key)</span>
}

// GenerateLicense creates a new signed license for the given parameters
func GenerateLicense(email string, tier LicenseTier, hardwareID string, privateKey *rsa.PrivateKey) (string, error) <span class="cov8" title="1">{
        now := time.Now()
        
        // Create license data
        license := &amp;License{
                Key:         generateLicenseKey(),
                Email:       email,
                Tier:        tier,
                IssuedAt:    now,
                ExpiresAt:   &amp;[]time.Time{now.AddDate(1, 0, 0)}[0], // 1 year expiration
                HardwareID:  hardwareID,
                Features:    getDefaultFeatures(tier),
        }
        
        // Set tier-specific limits
        switch tier </span>{
        case TierDeveloper:<span class="cov0" title="0">
                license.MaxDocuments = 1000
                license.MaxUsers = 1</span>
        case TierPro:<span class="cov8" title="1">
                license.MaxDocuments = 100000
                license.MaxUsers = 10</span>
        case TierEnterprise:<span class="cov0" title="0">
                license.MaxDocuments = 0 // unlimited
                license.MaxUsers = 0</span>     // unlimited
        }
        
        // Generate signature using same format as validation
        <span class="cov8" title="1">licenseData := map[string]interface{}{
                "key":           license.Key,
                "email":         license.Email,
                "tier":          license.Tier,
                "issued_at":     license.IssuedAt,
                "expires_at":    license.ExpiresAt,
                "max_documents": license.MaxDocuments,
                "max_users":     license.MaxUsers,
                "hardware_id":   license.HardwareID,
                "features":      license.Features,
        }

        dataBytes, _ := json.Marshal(licenseData)
        hash := sha256.Sum256(dataBytes)
        signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hash[:])
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign license: %w", err)
        }</span>

        <span class="cov8" title="1">license.Signature = base64.StdEncoding.EncodeToString(signature)
        
        // Convert license to JSON and encode as base64 for transport
        licenseJSON, err := json.Marshal(license)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal license: %w", err)
        }</span>
        
        <span class="cov8" title="1">return base64.StdEncoding.EncodeToString(licenseJSON), nil</span>
}

// getDefaultFeatures returns default features for a given tier
func getDefaultFeatures(tier LicenseTier) []string <span class="cov8" title="1">{
        switch tier </span>{
        case TierDeveloper:<span class="cov8" title="1">
                return getDeveloperFeatures()</span>
        case TierPro:<span class="cov8" title="1">
                return getProFeatures()</span>
        case TierEnterprise:<span class="cov8" title="1">
                return getEnterpriseFeatures()</span>
        default:<span class="cov8" title="1">
                return getDeveloperFeatures()</span>
        }
}

// LicenseFeatureGate implements the FeatureGate interface
type LicenseFeatureGate struct {
        tier LicenseTier
}

// NewFeatureGate creates a new feature gate based on current license
func NewFeatureGate() *LicenseFeatureGate <span class="cov8" title="1">{
        // Try to load license from common locations
        licenseLocations := []string{
                "license.json",
                "contextlite-license.json",
                filepath.Join(os.Getenv("HOME"), ".contextlite", "license.json"),
                filepath.Join(os.Getenv("USERPROFILE"), ".contextlite", "license.json"),
        }
        
        lm := NewLicenseManager()
        for _, location := range licenseLocations </span><span class="cov8" title="1">{
                if err := lm.LoadLicense(location); err == nil </span><span class="cov0" title="0">{
                        return &amp;LicenseFeatureGate{
                                tier: lm.GetTier(),
                        }
                }</span>
        }
        
        // No license found - default to developer tier
        <span class="cov8" title="1">return &amp;LicenseFeatureGate{
                tier: TierDeveloper,
        }</span>
}

// IsEnabled checks if a feature is enabled for current license
func (fg *LicenseFeatureGate) IsEnabled(feature string) bool <span class="cov8" title="1">{
        features := getDefaultFeatures(fg.tier)
        for _, f := range features </span><span class="cov8" title="1">{
                if f == feature </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// RequireFeature returns error if feature not available
func (fg *LicenseFeatureGate) RequireFeature(feature string) error <span class="cov8" title="1">{
        if !fg.IsEnabled(feature) </span><span class="cov8" title="1">{
                return fmt.Errorf("feature '%s' requires %s license or higher", feature, TierPro)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// RequireProfessional ensures Professional+ license
func (fg *LicenseFeatureGate) RequireProfessional() error <span class="cov8" title="1">{
        if fg.tier == TierDeveloper </span><span class="cov8" title="1">{
                return fmt.Errorf("this feature requires Professional license or higher")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RequireEnterprise ensures Enterprise license
func (fg *LicenseFeatureGate) RequireEnterprise() error <span class="cov8" title="1">{
        if fg.tier != TierEnterprise </span><span class="cov8" title="1">{
                return fmt.Errorf("this feature requires Enterprise license")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetTier returns current license tier
func (fg *LicenseFeatureGate) GetTier() string <span class="cov8" title="1">{
        return string(fg.tier)
}</span>

// ValidateCustomMCP validates custom MCP feature access
func (fg *LicenseFeatureGate) ValidateCustomMCP() error <span class="cov8" title="1">{
        return fg.RequireEnterprise()
}</span>

// ValidateMultiTenant validates multi-tenant feature access  
func (fg *LicenseFeatureGate) ValidateMultiTenant() error <span class="cov8" title="1">{
        return fg.RequireEnterprise()
}</span>

// ValidateLicense validates a license string using RSA public key verification
func ValidateLicense(licenseString string, publicKey *rsa.PublicKey) (bool, error) <span class="cov8" title="1">{
        // Parse the license JSON
        var license License
        if err := json.Unmarshal([]byte(licenseString), &amp;license); err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("invalid license JSON: %w", err)
        }</span>
        
        // Create verification payload (excluding signature)
        <span class="cov8" title="1">licenseData := map[string]interface{}{
                "key":           license.Key,
                "email":         license.Email,
                "tier":          license.Tier,
                "issued_at":     license.IssuedAt,
                "expires_at":    license.ExpiresAt,
                "max_documents": license.MaxDocuments,
                "max_users":     license.MaxUsers,
                "hardware_id":   license.HardwareID,
                "features":      license.Features,
        }
        
        // Create hash of license data
        dataBytes, _ := json.Marshal(licenseData)
        hash := sha256.Sum256(dataBytes)
        
        // Decode signature
        signature, err := base64.StdEncoding.DecodeString(license.Signature)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("invalid signature encoding: %w", err)
        }</span>
        
        // Verify signature
        <span class="cov8" title="1">err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hash[:], signature)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("signature verification failed: %w", err)
        }</span>
        
        // Check expiration
        <span class="cov0" title="0">if license.ExpiresAt != nil &amp;&amp; time.Now().After(*license.ExpiresAt) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("license expired on %v", *license.ExpiresAt)
        }</span>
        
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package license

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "time"
)

// TrackedLicenseManager handles license validation with server-side tracking
type TrackedLicenseManager struct {
        *LicenseManager
        serverURL    string
        activationID string
        httpClient   *http.Client
}

// ActivationResponse represents the server response for license activation
type ActivationResponse struct {
        Success    bool                `json:"success"`
        Activation *LicenseActivation  `json:"activation,omitempty"`
        Error      string              `json:"error,omitempty"`
        Message    string              `json:"message,omitempty"`
}

// NewTrackedLicenseManager creates a license manager with server tracking
func NewTrackedLicenseManager(serverURL string) *TrackedLicenseManager <span class="cov8" title="1">{
        return &amp;TrackedLicenseManager{
                LicenseManager: NewLicenseManager(),
                serverURL:      strings.TrimSuffix(serverURL, "/"),
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }
}</span>

// LoadLicenseWithActivation loads license and activates it with the server
func (tlm *TrackedLicenseManager) LoadLicenseWithActivation(licensePath string) error <span class="cov8" title="1">{
        // First load and validate the license locally
        if err := tlm.LicenseManager.LoadLicense(licensePath); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("local license validation failed: %w", err)
        }</span>

        // Get hardware fingerprint
        <span class="cov0" title="0">hardwareID, err := getHardwareFingerprint()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get hardware fingerprint: %w", err)
        }</span>

        // Activate with server
        <span class="cov0" title="0">activation, err := tlm.activateWithServer(tlm.license, hardwareID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server activation failed: %w", err)
        }</span>

        <span class="cov0" title="0">tlm.activationID = activation.ActivationID

        // Record activation locally for offline verification
        if err := tlm.saveActivationRecord(activation); err != nil </span><span class="cov0" title="0">{
                // Don't fail if we can't save locally, just log
                fmt.Printf("Warning: failed to save activation record: %v\n", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// activateWithServer activates the license on the tracking server
func (tlm *TrackedLicenseManager) activateWithServer(license *License, hardwareID string) (*LicenseActivation, error) <span class="cov8" title="1">{
        payload := map[string]interface{}{
                "license_key": license.Key,
                "email":       license.Email,
                "hardware_id": hardwareID,
                "tier":        string(license.Tier),
        }

        jsonData, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal activation request: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("POST", tlm.serverURL+"/activate", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create activation request: %w", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("User-Agent", fmt.Sprintf("ContextLite/%s (%s; %s)", "1.0.0", runtime.GOOS, runtime.GOARCH))

        resp, err := tlm.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("activation request failed: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read activation response: %w", err)
        }</span>

        <span class="cov8" title="1">var activationResp ActivationResponse
        if err := json.Unmarshal(body, &amp;activationResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse activation response: %w", err)
        }</span>

        <span class="cov8" title="1">if !activationResp.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("activation failed: %s", activationResp.Error)
        }</span>

        <span class="cov8" title="1">return activationResp.Activation, nil</span>
}

// RecordUsage sends usage events to the tracking server
func (tlm *TrackedLicenseManager) RecordUsage(eventType string, metadata map[string]interface{}) error <span class="cov8" title="1">{
        if tlm.activationID == "" </span><span class="cov8" title="1">{
                // No activation ID means offline mode - skip tracking
                return nil
        }</span>

        <span class="cov8" title="1">payload := map[string]interface{}{
                "license_key":   tlm.license.Key,
                "activation_id": tlm.activationID,
                "event_type":    eventType,
                "metadata":      metadata,
        }

        jsonData, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal usage event: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("POST", tlm.serverURL+"/usage", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create usage request: %w", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")

        // Send async to avoid blocking
        go func() </span><span class="cov8" title="1">{
                resp, err := tlm.httpClient.Do(req)
                if err != nil </span><span class="cov8" title="1">{
                        // Silently ignore network errors for usage tracking
                        return
                }</span>
                <span class="cov0" title="0">resp.Body.Close()</span>
        }()

        <span class="cov8" title="1">return nil</span>
}

// ValidateWithServer performs online license validation
func (tlm *TrackedLicenseManager) ValidateWithServer() error <span class="cov8" title="1">{
        if tlm.license == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no license loaded")
        }</span>

        <span class="cov8" title="1">hardwareID, err := getHardwareFingerprint()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get hardware fingerprint: %w", err)
        }</span>

        // Try to load existing activation
        <span class="cov8" title="1">if tlm.activationID == "" </span><span class="cov0" title="0">{
                activation, err := tlm.loadActivationRecord()
                if err == nil &amp;&amp; activation != nil </span><span class="cov0" title="0">{
                        tlm.activationID = activation.ActivationID
                }</span>
        }

        // For now, just record a validation event
        <span class="cov8" title="1">metadata := map[string]interface{}{
                "hardware_id": hardwareID,
                "validation_time": time.Now().Format(time.RFC3339),
        }

        return tlm.RecordUsage("license_validation", metadata)</span>
}

// DeactivateFromServer deactivates the license on the server
func (tlm *TrackedLicenseManager) DeactivateFromServer() error <span class="cov8" title="1">{
        if tlm.license == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no license loaded")
        }</span>

        <span class="cov8" title="1">hardwareID, err := getHardwareFingerprint()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get hardware fingerprint: %w", err)
        }</span>

        <span class="cov8" title="1">payload := map[string]interface{}{
                "license_key": tlm.license.Key,
                "hardware_id": hardwareID,
        }

        jsonData, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal deactivation request: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("POST", tlm.serverURL+"/deactivate", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create deactivation request: %w", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")

        resp, err := tlm.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("deactivation request failed: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Clear local activation record
        tlm.activationID = ""
        tlm.clearActivationRecord()

        return nil</span>
}

// saveActivationRecord saves activation info locally for offline use
func (tlm *TrackedLicenseManager) saveActivationRecord(activation *LicenseActivation) error <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">contextDir := filepath.Join(homeDir, ".contextlite")
        os.MkdirAll(contextDir, 0755)

        activationPath := filepath.Join(contextDir, "activation.json")
        
        data, err := json.MarshalIndent(activation, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return os.WriteFile(activationPath, data, 0644)</span>
}

// loadActivationRecord loads activation info from local storage
func (tlm *TrackedLicenseManager) loadActivationRecord() (*LicenseActivation, error) <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">activationPath := filepath.Join(homeDir, ".contextlite", "activation.json")
        
        data, err := os.ReadFile(activationPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var activation LicenseActivation
        if err := json.Unmarshal(data, &amp;activation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;activation, nil</span>
}

// clearActivationRecord removes local activation record
func (tlm *TrackedLicenseManager) clearActivationRecord() error <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">activationPath := filepath.Join(homeDir, ".contextlite", "activation.json")
        return os.Remove(activationPath)</span>
}

// Enhanced feature gate with tracking integration
type TrackedFeatureGate struct {
        *EnhancedFeatureGate
        tracker *TrackedLicenseManager
}

// NewTrackedFeatureGate creates a feature gate with usage tracking
func NewTrackedFeatureGate(serverURL string) *TrackedFeatureGate <span class="cov8" title="1">{
        enhancedGate := NewEnhancedFeatureGate()
        tracker := NewTrackedLicenseManager(serverURL)
        
        // Try to load license with activation
        licenseLocations := []string{
                "license.json",
                "contextlite-license.json",
                filepath.Join(os.Getenv("HOME"), ".contextlite", "license.json"),
                filepath.Join(os.Getenv("USERPROFILE"), ".contextlite", "license.json"),
        }
        
        for _, location := range licenseLocations </span><span class="cov8" title="1">{
                if err := tracker.LoadLicenseWithActivation(location); err == nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        
        <span class="cov8" title="1">return &amp;TrackedFeatureGate{
                EnhancedFeatureGate: enhancedGate,
                tracker:             tracker,
        }</span>
}

// RequireFeature with usage tracking
func (tfg *TrackedFeatureGate) RequireFeature(feature string) error <span class="cov8" title="1">{
        // Record feature usage attempt
        metadata := map[string]interface{}{
                "feature": feature,
                "tier":    tfg.GetTier(),
                "allowed": tfg.IsEnabled(feature),
        }
        
        tfg.tracker.RecordUsage("feature_request", metadata)
        
        // Call parent implementation
        return tfg.EnhancedFeatureGate.RequireFeature(feature)
}</span>

// TrackStartup records application startup event
func (tfg *TrackedFeatureGate) TrackStartup() <span class="cov8" title="1">{
        metadata := map[string]interface{}{
                "version": "1.0.0",
                "os":      runtime.GOOS,
                "arch":    runtime.GOARCH,
                "tier":    tfg.GetTier(),
        }
        
        tfg.tracker.RecordUsage("app_startup", metadata)
}</span>

// TrackQuery records context query events
func (tfg *TrackedFeatureGate) TrackQuery(queryType string, duration time.Duration, resultCount int) <span class="cov8" title="1">{
        metadata := map[string]interface{}{
                "query_type":   queryType,
                "duration_ms":  duration.Milliseconds(),
                "result_count": resultCount,
                "tier":         tfg.GetTier(),
        }
        
        tfg.tracker.RecordUsage("context_query", metadata)
}</span>

// TrackError records error events for debugging
func (tfg *TrackedFeatureGate) TrackError(errorType string, errorMessage string) <span class="cov8" title="1">{
        metadata := map[string]interface{}{
                "error_type":    errorType,
                "error_message": errorMessage,
                "tier":          tfg.GetTier(),
        }
        
        tfg.tracker.RecordUsage("error_event", metadata)
}</span>

// GetActivationID returns the current activation ID for debugging
func (tfg *TrackedFeatureGate) GetActivationID() string <span class="cov8" title="1">{
        return tfg.tracker.activationID
}</span>

// ValidateOnline performs online license validation
func (tfg *TrackedFeatureGate) ValidateOnline() error <span class="cov8" title="1">{
        return tfg.tracker.ValidateWithServer()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package license

import (
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "log"
        "sync"
        "time"

        _ "modernc.org/sqlite"
)

// truncateString safely truncates a string to the specified length
func truncateString(s string, length int) string <span class="cov8" title="1">{
        if len(s) &lt;= length </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return s[:length]</span>
}

// LicenseTracker handles comprehensive license tracking and analytics
type LicenseTracker struct {
        db             *sql.DB
        activationAPI  string
        deactivationAPI string
        mu             sync.RWMutex
}

// LicenseActivation represents a license activation record
type LicenseActivation struct {
        ID               int       `json:"id"`
        LicenseKey       string    `json:"license_key"`
        Email           string    `json:"email"`
        HardwareID      string    `json:"hardware_id"`
        ActivationID    string    `json:"activation_id"`
        IPAddress       string    `json:"ip_address"`
        UserAgent       string    `json:"user_agent"`
        ActivatedAt     time.Time `json:"activated_at"`
        LastSeen        time.Time `json:"last_seen"`
        IsActive        bool      `json:"is_active"`
        ActivationCount int       `json:"activation_count"`
        MaxActivations  int       `json:"max_activations"`
        CustomerID      string    `json:"customer_id"`
        Tier            string    `json:"tier"`
}

// UsageEvent represents usage analytics
type UsageEvent struct {
        ID           int       `json:"id"`
        LicenseKey   string    `json:"license_key"`
        ActivationID string    `json:"activation_id"`
        EventType    string    `json:"event_type"` // startup, query, build, etc.
        Timestamp    time.Time `json:"timestamp"`
        Metadata     string    `json:"metadata"` // JSON metadata
        IPAddress    string    `json:"ip_address"`
}

// SecurityEvent represents security-related events
type SecurityEvent struct {
        ID           int       `json:"id"`
        LicenseKey   string    `json:"license_key"`
        EventType    string    `json:"event_type"` // invalid_signature, hardware_mismatch, etc.
        Description  string    `json:"description"`
        IPAddress    string    `json:"ip_address"`
        UserAgent    string    `json:"user_agent"`
        Timestamp    time.Time `json:"timestamp"`
        Severity     string    `json:"severity"` // low, medium, high, critical
}

// LicenseAnalytics provides business intelligence
type LicenseAnalytics struct {
        TotalLicenses    int `json:"total_licenses"`
        ActiveLicenses   int `json:"active_licenses"`
        TrialConversions int `json:"trial_conversions"`
        DailyActiveUsers int `json:"daily_active_users"`
        Revenue          struct {
                Monthly int64 `json:"monthly"`
                Total   int64 `json:"total"`
        } `json:"revenue"`
        TopFeatures []FeatureUsage `json:"top_features"`
}

type FeatureUsage struct {
        Feature string `json:"feature"`
        Count   int    `json:"count"`
}

// NewLicenseTracker creates a new license tracker with SQLite backend
func NewLicenseTracker(dbPath string) (*LicenseTracker, error) <span class="cov8" title="1">{
        db, err := sql.Open("sqlite", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov8" title="1">tracker := &amp;LicenseTracker{
                db:             db,
                activationAPI:  "https://api.contextlite.com/v1/activate",
                deactivationAPI: "https://api.contextlite.com/v1/deactivate",
        }

        if err := tracker.initDatabase(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize database: %w", err)
        }</span>

        <span class="cov8" title="1">return tracker, nil</span>
}

// initDatabase creates the necessary tables
func (lt *LicenseTracker) initDatabase() error <span class="cov8" title="1">{
        schema := `
        CREATE TABLE IF NOT EXISTS license_activations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                license_key TEXT NOT NULL,
                email TEXT NOT NULL,
                hardware_id TEXT NOT NULL,
                activation_id TEXT UNIQUE NOT NULL,
                ip_address TEXT,
                user_agent TEXT,
                activated_at DATETIME NOT NULL,
                last_seen DATETIME NOT NULL,
                is_active BOOLEAN DEFAULT 1,
                activation_count INTEGER DEFAULT 1,
                max_activations INTEGER DEFAULT 3,
                customer_id TEXT,
                tier TEXT,
                UNIQUE(license_key, hardware_id)
        );

        CREATE TABLE IF NOT EXISTS usage_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                license_key TEXT NOT NULL,
                activation_id TEXT NOT NULL,
                event_type TEXT NOT NULL,
                timestamp DATETIME NOT NULL,
                metadata TEXT,
                ip_address TEXT,
                FOREIGN KEY(activation_id) REFERENCES license_activations(activation_id)
        );

        CREATE TABLE IF NOT EXISTS security_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                license_key TEXT,
                event_type TEXT NOT NULL,
                description TEXT,
                ip_address TEXT,
                user_agent TEXT,
                timestamp DATETIME NOT NULL,
                severity TEXT DEFAULT 'medium'
        );

        CREATE INDEX IF NOT EXISTS idx_activations_license ON license_activations(license_key);
        CREATE INDEX IF NOT EXISTS idx_activations_hardware ON license_activations(hardware_id);
        CREATE INDEX IF NOT EXISTS idx_usage_license ON usage_events(license_key);
        CREATE INDEX IF NOT EXISTS idx_security_timestamp ON security_events(timestamp);
        `

        _, err := lt.db.Exec(schema)
        return err
}</span>

// ActivateLicense records a license activation with comprehensive tracking
func (lt *LicenseTracker) ActivateLicense(licenseKey, email, hardwareID, ipAddress, userAgent string, tier LicenseTier) (*LicenseActivation, error) <span class="cov8" title="1">{
        lt.mu.Lock()
        defer lt.mu.Unlock()
        
        // Generate unique activation ID
        activationID := lt.generateActivationID(licenseKey, hardwareID)

        // Check if already activated on this hardware
        existing, err := lt.getActivation(licenseKey, hardwareID)
        if err == nil &amp;&amp; existing != nil &amp;&amp; existing.IsActive </span><span class="cov0" title="0">{
                // Update last seen
                existing.LastSeen = time.Now()
                lt.updateLastSeen(existing.ActivationID)
                return existing, nil
        }</span>

        // If we have a deactivated license on this hardware, reactivate it
        <span class="cov8" title="1">if err == nil &amp;&amp; existing != nil &amp;&amp; !existing.IsActive </span><span class="cov0" title="0">{
                err = lt.reactivateLicense(licenseKey, hardwareID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to reactivate license: %w", err)
                }</span>
                <span class="cov0" title="0">existing.IsActive = true
                existing.LastSeen = time.Now()
                return existing, nil</span>
        }

        // Check activation limits
        <span class="cov8" title="1">activationCount, err := lt.getActivationCount(licenseKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check activation count: %w", err)
        }</span>

        <span class="cov8" title="1">maxActivations := lt.getMaxActivations(tier)
        if activationCount &gt;= maxActivations </span><span class="cov8" title="1">{
                lt.recordSecurityEvent(licenseKey, "activation_limit_exceeded",
                        fmt.Sprintf("License already activated on %d devices (max: %d)", activationCount, maxActivations),
                        ipAddress, userAgent, "high")
                return nil, fmt.Errorf("license activation limit exceeded (%d/%d)", activationCount, maxActivations)
        }</span>

        // Create new activation
        <span class="cov8" title="1">activation := &amp;LicenseActivation{
                LicenseKey:      licenseKey,
                Email:          email,
                HardwareID:     hardwareID,
                ActivationID:   activationID,
                IPAddress:      ipAddress,
                UserAgent:      userAgent,
                ActivatedAt:    time.Now(),
                LastSeen:       time.Now(),
                IsActive:       true,
                ActivationCount: activationCount + 1,
                MaxActivations: maxActivations,
                Tier:           string(tier),
        }

        err = lt.saveActivation(activation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save activation: %w", err)
        }</span>

        // Record usage event
        <span class="cov8" title="1">lt.recordUsageEvent(licenseKey, activationID, "license_activated", "", ipAddress)

        log.Printf("License activated: %s on hardware %s (activation %d/%d)",
                truncateString(licenseKey, 8)+"...", truncateString(hardwareID, 8)+"...", activationCount+1, maxActivations)

        return activation, nil</span>
}

// RecordUsage tracks feature usage for analytics
func (lt *LicenseTracker) RecordUsage(licenseKey, activationID, eventType string, metadata map[string]interface{}, ipAddress string) error <span class="cov8" title="1">{
        metadataJSON := ""
        if metadata != nil </span><span class="cov8" title="1">{
                data, _ := json.Marshal(metadata)
                metadataJSON = string(data)
        }</span>

        <span class="cov8" title="1">return lt.recordUsageEvent(licenseKey, activationID, eventType, metadataJSON, ipAddress)</span>
}

// ValidateActivation checks if a license activation is valid and updates last seen
func (lt *LicenseTracker) ValidateActivation(licenseKey, hardwareID string) (*LicenseActivation, error) <span class="cov8" title="1">{
        lt.mu.RLock()
        defer lt.mu.RUnlock()
        
        activation, err := lt.getActivation(licenseKey, hardwareID)
        if err != nil </span><span class="cov8" title="1">{
                lt.recordSecurityEvent(licenseKey, "validation_failed",
                        fmt.Sprintf("Failed to validate activation: %v", err), "", "", "medium")
                return nil, err
        }</span>

        <span class="cov8" title="1">if activation == nil </span><span class="cov8" title="1">{
                lt.recordSecurityEvent(licenseKey, "unauthorized_access",
                        "License not activated on this hardware", "", "", "high")
                return nil, fmt.Errorf("license not activated on this hardware")
        }</span>

        <span class="cov8" title="1">if !activation.IsActive </span><span class="cov8" title="1">{
                lt.recordSecurityEvent(licenseKey, "inactive_license_access",
                        "Attempted to use deactivated license", "", "", "high")
                return nil, fmt.Errorf("license has been deactivated")
        }</span>

        // Update last seen
        <span class="cov8" title="1">lt.updateLastSeen(activation.ActivationID)

        return activation, nil</span>
}

// DeactivateLicense removes a license activation
func (lt *LicenseTracker) DeactivateLicense(licenseKey, hardwareID string) error <span class="cov8" title="1">{
        lt.mu.Lock()
        defer lt.mu.Unlock()
        
        query := `UPDATE license_activations SET is_active = 0 WHERE license_key = ? AND hardware_id = ?`
        _, err := lt.db.Exec(query, licenseKey, hardwareID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">lt.recordUsageEvent(licenseKey, "", "license_deactivated", "", "")
        return nil</span>
}

// reactivateLicense reactivates a previously deactivated license
func (lt *LicenseTracker) reactivateLicense(licenseKey, hardwareID string) error <span class="cov8" title="1">{
        query := `UPDATE license_activations SET is_active = 1, last_seen = CURRENT_TIMESTAMP WHERE license_key = ? AND hardware_id = ?`
        _, err := lt.db.Exec(query, licenseKey, hardwareID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">lt.recordUsageEvent(licenseKey, "", "license_reactivated", "", "")
        return nil</span>
}

// GetAnalytics provides comprehensive business analytics
func (lt *LicenseTracker) GetAnalytics(days int) (*LicenseAnalytics, error) <span class="cov8" title="1">{
        since := time.Now().AddDate(0, 0, -days)

        analytics := &amp;LicenseAnalytics{}

        // Total licenses
        err := lt.db.QueryRow(`SELECT COUNT(DISTINCT license_key) FROM license_activations`).Scan(&amp;analytics.TotalLicenses)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Active licenses (seen in last 30 days)
        <span class="cov8" title="1">err = lt.db.QueryRow(`
                SELECT COUNT(DISTINCT license_key) 
                FROM license_activations 
                WHERE is_active = 1 AND last_seen &gt; ?
        `, time.Now().AddDate(0, 0, -30)).Scan(&amp;analytics.ActiveLicenses)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Daily active users
        <span class="cov8" title="1">err = lt.db.QueryRow(`
                SELECT COUNT(DISTINCT license_key) 
                FROM usage_events 
                WHERE timestamp &gt; ?
        `, time.Now().AddDate(0, 0, -1)).Scan(&amp;analytics.DailyActiveUsers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Top features
        <span class="cov8" title="1">rows, err := lt.db.Query(`
                SELECT event_type, COUNT(*) as count 
                FROM usage_events 
                WHERE timestamp &gt; ? 
                GROUP BY event_type 
                ORDER BY count DESC 
                LIMIT 10
        `, since)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var feature FeatureUsage
                err := rows.Scan(&amp;feature.Feature, &amp;feature.Count)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">analytics.TopFeatures = append(analytics.TopFeatures, feature)</span>
        }

        <span class="cov8" title="1">return analytics, nil</span>
}

// Helper methods

func (lt *LicenseTracker) generateActivationID(licenseKey, hardwareID string) string <span class="cov8" title="1">{
        data := fmt.Sprintf("%s:%s:%d", licenseKey, hardwareID, time.Now().UnixNano())
        hash := sha256.Sum256([]byte(data))
        return hex.EncodeToString(hash[:16])
}</span>

func (lt *LicenseTracker) getMaxActivations(tier LicenseTier) int <span class="cov8" title="1">{
        switch tier </span>{
        case TierDeveloper:<span class="cov8" title="1">
                return 1</span>
        case TierPro:<span class="cov8" title="1">
                return 3</span>
        case TierEnterprise:<span class="cov8" title="1">
                return 10</span>
        default:<span class="cov0" title="0">
                return 1</span>
        }
}

func (lt *LicenseTracker) getActivation(licenseKey, hardwareID string) (*LicenseActivation, error) <span class="cov8" title="1">{
        query := `
                SELECT id, license_key, email, hardware_id, activation_id, ip_address, 
                       user_agent, activated_at, last_seen, is_active, activation_count, 
                       max_activations, customer_id, tier
                FROM license_activations 
                WHERE license_key = ? AND hardware_id = ?
        `

        activation := &amp;LicenseActivation{}
        err := lt.db.QueryRow(query, licenseKey, hardwareID).Scan(
                &amp;activation.ID, &amp;activation.LicenseKey, &amp;activation.Email,
                &amp;activation.HardwareID, &amp;activation.ActivationID, &amp;activation.IPAddress,
                &amp;activation.UserAgent, &amp;activation.ActivatedAt, &amp;activation.LastSeen,
                &amp;activation.IsActive, &amp;activation.ActivationCount, &amp;activation.MaxActivations,
                &amp;activation.CustomerID, &amp;activation.Tier,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return activation, err</span>
}

func (lt *LicenseTracker) getActivationCount(licenseKey string) (int, error) <span class="cov8" title="1">{
        var count int
        err := lt.db.QueryRow(`SELECT COUNT(*) FROM license_activations WHERE license_key = ? AND is_active = 1`, licenseKey).Scan(&amp;count)
        return count, err
}</span>

func (lt *LicenseTracker) saveActivation(activation *LicenseActivation) error <span class="cov8" title="1">{
        query := `
                INSERT INTO license_activations 
                (license_key, email, hardware_id, activation_id, ip_address, user_agent, 
                 activated_at, last_seen, is_active, activation_count, max_activations, 
                 customer_id, tier) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := lt.db.Exec(query,
                activation.LicenseKey, activation.Email, activation.HardwareID,
                activation.ActivationID, activation.IPAddress, activation.UserAgent,
                activation.ActivatedAt, activation.LastSeen, activation.IsActive,
                activation.ActivationCount, activation.MaxActivations,
                activation.CustomerID, activation.Tier,
        )

        return err
}</span>

func (lt *LicenseTracker) updateLastSeen(activationID string) error <span class="cov8" title="1">{
        query := `UPDATE license_activations SET last_seen = ? WHERE activation_id = ?`
        _, err := lt.db.Exec(query, time.Now(), activationID)
        return err
}</span>

func (lt *LicenseTracker) recordUsageEvent(licenseKey, activationID, eventType, metadata, ipAddress string) error <span class="cov8" title="1">{
        query := `
                INSERT INTO usage_events (license_key, activation_id, event_type, timestamp, metadata, ip_address)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err := lt.db.Exec(query, licenseKey, activationID, eventType, time.Now(), metadata, ipAddress)
        return err
}</span>

func (lt *LicenseTracker) recordSecurityEvent(licenseKey, eventType, description, ipAddress, userAgent, severity string) error <span class="cov8" title="1">{
        query := `
                INSERT INTO security_events (license_key, event_type, description, ip_address, user_agent, timestamp, severity)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err := lt.db.Exec(query, licenseKey, eventType, description, ipAddress, userAgent, time.Now(), severity)
        return err
}</span>

// GetSecurityEvents returns recent security events for monitoring
func (lt *LicenseTracker) GetSecurityEvents(hours int) ([]SecurityEvent, error) <span class="cov8" title="1">{
        since := time.Now().Add(-time.Duration(hours) * time.Hour)
        query := `
                SELECT id, license_key, event_type, description, ip_address, user_agent, timestamp, severity
                FROM security_events 
                WHERE timestamp &gt; ? 
                ORDER BY timestamp DESC
        `

        rows, err := lt.db.Query(query, since)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var events []SecurityEvent
        for rows.Next() </span><span class="cov8" title="1">{
                var event SecurityEvent
                err := rows.Scan(&amp;event.ID, &amp;event.LicenseKey, &amp;event.EventType,
                        &amp;event.Description, &amp;event.IPAddress, &amp;event.UserAgent,
                        &amp;event.Timestamp, &amp;event.Severity)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">events = append(events, event)</span>
        }

        <span class="cov8" title="1">return events, nil</span>
}

// Close closes the database connection
func (lt *LicenseTracker) Close() error <span class="cov8" title="1">{
        return lt.db.Close()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package license

import (
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"
)

// TrialStatus represents the current trial state
type TrialStatus string

const (
        TrialStatusActive  TrialStatus = "active"
        TrialStatusExpired TrialStatus = "expired"
        TrialStatusNew     TrialStatus = "new"
)

// TrialManager handles 14-day trial tracking
type TrialManager struct {
        trialFile string
        hwID      string
}

// TrialInfo contains trial tracking data
type TrialInfo struct {
        StartDate     time.Time `json:"start_date"`
        HardwareID    string    `json:"hardware_id"`
        InstallID     string    `json:"install_id"`
        TrialDays     int       `json:"trial_days"`
        ExpiresAt     time.Time `json:"expires_at"`
        FirstRun      bool      `json:"first_run"`
        UsageCount    int       `json:"usage_count"`
}

// NewTrialManager creates a new trial manager
func NewTrialManager() *TrialManager <span class="cov8" title="1">{
        homeDir, _ := os.UserHomeDir()
        contextDir := filepath.Join(homeDir, ".contextlite")
        os.MkdirAll(contextDir, 0755)
        
        trialPath := filepath.Join(contextDir, "trial.json")
        
        hwID, _ := getHardwareFingerprint()
        
        return &amp;TrialManager{
                trialFile: trialPath,
                hwID:      hwID,
        }
}</span>

// StartOrGetTrial initializes or retrieves existing trial
func (tm *TrialManager) StartOrGetTrial() (*TrialInfo, error) <span class="cov8" title="1">{
        // Check if trial exists
        if trial, err := tm.loadExistingTrial(); err == nil </span><span class="cov8" title="1">{
                // Validate hardware binding
                if trial.HardwareID != tm.hwID </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("trial is bound to different hardware")
                }</span>
                
                // Increment usage count
                <span class="cov8" title="1">trial.UsageCount++
                tm.saveTrial(trial)
                
                return trial, nil</span>
        }
        
        // Start new trial
        <span class="cov0" title="0">trial := &amp;TrialInfo{
                StartDate:  time.Now(),
                HardwareID: tm.hwID,
                InstallID:  tm.generateInstallID(),
                TrialDays:  14,
                ExpiresAt:  time.Now().AddDate(0, 0, 14),
                FirstRun:   true,
                UsageCount: 1,
        }
        
        if err := tm.saveTrial(trial); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save trial info: %w", err)
        }</span>
        
        <span class="cov0" title="0">return trial, nil</span>
}

// GetTrialStatus returns current trial status
func (tm *TrialManager) GetTrialStatus() (TrialStatus, *TrialInfo, error) <span class="cov8" title="1">{
        trial, err := tm.loadExistingTrial()
        if err != nil </span><span class="cov0" title="0">{
                return TrialStatusNew, nil, nil
        }</span>
        
        // Validate hardware binding
        <span class="cov8" title="1">if trial.HardwareID != tm.hwID </span><span class="cov0" title="0">{
                return TrialStatusExpired, trial, fmt.Errorf("trial bound to different hardware")
        }</span>
        
        <span class="cov8" title="1">if time.Now().After(trial.ExpiresAt) </span><span class="cov0" title="0">{
                return TrialStatusExpired, trial, nil
        }</span>
        
        <span class="cov8" title="1">return TrialStatusActive, trial, nil</span>
}

// IsTrialActive checks if trial is currently active
func (tm *TrialManager) IsTrialActive() bool <span class="cov8" title="1">{
        status, _, _ := tm.GetTrialStatus()
        return status == TrialStatusActive || status == TrialStatusNew
}</span>

// DaysRemaining returns days left in trial
func (tm *TrialManager) DaysRemaining() int <span class="cov8" title="1">{
        trial, err := tm.loadExistingTrial()
        if err != nil </span><span class="cov0" title="0">{
                return 14 // New installation
        }</span>
        
        <span class="cov8" title="1">remaining := time.Until(trial.ExpiresAt).Hours() / 24
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return int(remaining)</span>
}

// GetTrialInfo returns detailed trial information
func (tm *TrialManager) GetTrialInfo() map[string]interface{} <span class="cov8" title="1">{
        status, trial, err := tm.GetTrialStatus()
        
        info := map[string]interface{}{
                "status":      string(status),
                "is_active":   status == TrialStatusActive || status == TrialStatusNew,
                "days_total":  14,
        }
        
        if err != nil </span><span class="cov0" title="0">{
                info["error"] = err.Error()
                info["days_remaining"] = 0
                return info
        }</span>
        
        <span class="cov8" title="1">if trial != nil </span><span class="cov8" title="1">{
                info["days_remaining"] = tm.DaysRemaining()
                info["start_date"] = trial.StartDate.Format("2006-01-02")
                info["expires_at"] = trial.ExpiresAt.Format("2006-01-02")
                info["usage_count"] = trial.UsageCount
                info["first_run"] = trial.FirstRun
                info["install_id"] = trial.InstallID[:8] + "..." // Partial ID for privacy
        }</span> else<span class="cov0" title="0"> {
                info["days_remaining"] = 14
        }</span>
        
        <span class="cov8" title="1">return info</span>
}

// loadExistingTrial loads trial data from disk
func (tm *TrialManager) loadExistingTrial() (*TrialInfo, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(tm.trialFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">var trial TrialInfo
        if err := json.Unmarshal(data, &amp;trial); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">return &amp;trial, nil</span>
}

// saveTrial saves trial data to disk
func (tm *TrialManager) saveTrial(trial *TrialInfo) error <span class="cov8" title="1">{
        data, err := json.MarshalIndent(trial, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">return os.WriteFile(tm.trialFile, data, 0644)</span>
}

// generateInstallID creates a unique installation identifier
func (tm *TrialManager) generateInstallID() string <span class="cov8" title="1">{
        timestamp := time.Now().Unix()
        combined := fmt.Sprintf("%s:%d:%s", tm.hwID, timestamp, "contextlite-trial")
        hash := sha256.Sum256([]byte(combined))
        return hex.EncodeToString(hash[:16])
}</span>

// LicenseFeatureGate with trial support
type EnhancedFeatureGate struct {
        tier         LicenseTier
        status       string
        message      string
        trialManager *TrialManager
        license      *License
}

// NewEnhancedFeatureGate creates feature gate with trial support
func NewEnhancedFeatureGate() *EnhancedFeatureGate <span class="cov8" title="1">{
        trialMgr := NewTrialManager()
        
        // 1. Check for valid license first
        licenseLocations := []string{
                "license.json",
                "contextlite-license.json",
                filepath.Join(os.Getenv("HOME"), ".contextlite", "license.json"),
                filepath.Join(os.Getenv("USERPROFILE"), ".contextlite", "license.json"),
        }
        
        lm := NewLicenseManager()
        for _, location := range licenseLocations </span><span class="cov8" title="1">{
                if err := lm.LoadLicense(location); err == nil </span><span class="cov0" title="0">{
                        return &amp;EnhancedFeatureGate{
                                tier:    lm.GetTier(),
                                status:  "licensed",
                                message: fmt.Sprintf("Licensed: %s", lm.GetTier()),
                                license: lm.license,
                        }
                }</span>
        }
        
        // 2. Check trial status
        <span class="cov8" title="1">trialStatus, _, err := trialMgr.GetTrialStatus()
        
        if err != nil &amp;&amp; trialStatus != TrialStatusNew </span><span class="cov0" title="0">{
                return &amp;EnhancedFeatureGate{
                        tier:         TierDeveloper,
                        status:       "error",
                        message:      fmt.Sprintf("Trial error: %v", err),
                        trialManager: trialMgr,
                }
        }</span>
        
        <span class="cov8" title="1">switch trialStatus </span>{
        case TrialStatusNew:<span class="cov0" title="0">
                // Start new trial
                if _, err := trialMgr.StartOrGetTrial(); err != nil </span><span class="cov0" title="0">{
                        return &amp;EnhancedFeatureGate{
                                tier:         TierDeveloper,
                                status:       "error",
                                message:      "Failed to start trial",
                                trialManager: trialMgr,
                        }
                }</span>
                <span class="cov0" title="0">return &amp;EnhancedFeatureGate{
                        tier:         TierPro, // Full features during trial!
                        status:       "trial_started",
                        message:      "Trial started: 14 days of full features",
                        trialManager: trialMgr,
                }</span>
                
        case TrialStatusActive:<span class="cov8" title="1">
                remaining := trialMgr.DaysRemaining()
                return &amp;EnhancedFeatureGate{
                        tier:         TierPro, // Full features during trial!
                        status:       "trial_active",
                        message:      fmt.Sprintf("Trial active: %d days remaining", remaining),
                        trialManager: trialMgr,
                }</span>
                
        case TrialStatusExpired:<span class="cov0" title="0">
                return &amp;EnhancedFeatureGate{
                        tier:         TierDeveloper, // Fallback to limited features
                        status:       "trial_expired",
                        message:      "Trial expired. Purchase license to continue with full features.",
                        trialManager: trialMgr,
                }</span>
        }
        
        // Fallback
        <span class="cov0" title="0">return &amp;EnhancedFeatureGate{
                tier:         TierDeveloper,
                status:       "unknown",
                message:      "Unknown license state",
                trialManager: trialMgr,
        }</span>
}

// GetTier returns current access tier
func (fg *EnhancedFeatureGate) GetTier() string <span class="cov8" title="1">{
        return string(fg.tier)
}</span>

// GetStatus returns detailed status information
func (fg *EnhancedFeatureGate) GetStatus() map[string]interface{} <span class="cov8" title="1">{
        status := map[string]interface{}{
                "tier":    string(fg.tier),
                "status":  fg.status,
                "message": fg.message,
        }
        
        if fg.trialManager != nil </span><span class="cov8" title="1">{
                trialInfo := fg.trialManager.GetTrialInfo()
                status["trial"] = trialInfo
        }</span>
        
        <span class="cov8" title="1">if fg.license != nil </span><span class="cov0" title="0">{
                status["license"] = map[string]interface{}{
                        "email":        fg.license.Email,
                        "issued_at":    fg.license.IssuedAt.Format("2006-01-02"),
                        "max_documents": fg.license.MaxDocuments,
                        "features":     fg.license.Features,
                }
        }</span>
        
        <span class="cov8" title="1">return status</span>
}

// TrialDaysRemaining returns days left in trial (0 if no trial)
func (fg *EnhancedFeatureGate) TrialDaysRemaining() int <span class="cov8" title="1">{
        if fg.trialManager == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return fg.trialManager.DaysRemaining()</span>
}

// IsEnabled checks if a feature is available
func (fg *EnhancedFeatureGate) IsEnabled(feature string) bool <span class="cov8" title="1">{
        features := getDefaultFeatures(fg.tier)
        for _, f := range features </span><span class="cov8" title="1">{
                if f == feature </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// RequireFeature returns error if feature not available
func (fg *EnhancedFeatureGate) RequireFeature(feature string) error <span class="cov8" title="1">{
        if !fg.IsEnabled(feature) </span><span class="cov8" title="1">{
                if fg.status == "trial_expired" </span><span class="cov0" title="0">{
                        return fmt.Errorf("feature '%s' requires active license (trial expired)", feature)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("feature '%s' requires %s license or higher", feature, TierPro)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// RequireProfessional ensures Professional+ license
func (fg *EnhancedFeatureGate) RequireProfessional() error <span class="cov8" title="1">{
        if fg.tier == TierDeveloper &amp;&amp; fg.status == "trial_expired" </span><span class="cov0" title="0">{
                return fmt.Errorf("this feature requires Professional license or higher (trial expired)")
        }</span>
        <span class="cov8" title="1">if fg.tier == TierDeveloper &amp;&amp; fg.status != "trial_active" &amp;&amp; fg.status != "trial_started" </span><span class="cov0" title="0">{
                return fmt.Errorf("this feature requires Professional license or higher")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// RequireEnterprise ensures Enterprise license
func (fg *EnhancedFeatureGate) RequireEnterprise() error <span class="cov8" title="1">{
        if fg.tier != TierEnterprise </span><span class="cov8" title="1">{
                return fmt.Errorf("this feature requires Enterprise license")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ValidateCustomMCP validates custom MCP feature access
func (fg *EnhancedFeatureGate) ValidateCustomMCP() error <span class="cov8" title="1">{
        return fg.RequireEnterprise()
}</span>

// ValidateMultiTenant validates multi-tenant feature access  
func (fg *EnhancedFeatureGate) ValidateMultiTenant() error <span class="cov8" title="1">{
        return fg.RequireEnterprise()
}</span>

// CheckAccess validates access to system features
func (fg *EnhancedFeatureGate) CheckAccess(operation string) error <span class="cov8" title="1">{
        switch fg.status </span>{
        case "trial_expired":<span class="cov0" title="0">
                return fmt.Errorf("trial expired - purchase license to continue: https://contextlite.com/purchase")</span>
        case "error":<span class="cov0" title="0">
                return fmt.Errorf("license validation error: %s", fg.message)</span>
        case "licensed", "trial_active", "trial_started":<span class="cov8" title="1">
                return nil</span> // Full access
        default:<span class="cov0" title="0">
                return nil</span> // Allow access for unknown states (graceful degradation)
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
