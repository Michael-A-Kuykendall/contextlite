package solve

import (
	"context"
	"fmt"
	"os/exec"
	"regexp"
	"strconv"
	"strings"
	"time"

	"contextlite/internal/timing"
	"contextlite/pkg/types"
)

// Z3Optimizer provides true SMT optimization using Z3 Optimize
type Z3Optimizer struct {
	z3Path      string
	timeoutMs   int
	integerScale int
}

// NewZ3Optimizer creates a new Z3 optimizer
func NewZ3Optimizer(z3Path string, timeoutMs int) *Z3Optimizer {
	return &Z3Optimizer{
		z3Path:      z3Path,
		timeoutMs:   timeoutMs,
		integerScale: 10000, // Scale floats to integers for SMT
	}
}

// OptimizeResult represents the result of Z3 optimization
type OptimizeResult struct {
	SelectedDocs    []int
	ObjectiveValue  int
	SolveTimeUs     int64   // Microsecond precision timing
	SolveTimeMs     int     // Legacy millisecond timing for compatibility
	VariableCount   int
	ConstraintCount int
	Status          string  // "sat", "unknown", "unsat"
	TimedOut        bool
}

// OptimizeDocumentSelection performs true SMT optimization using Z3
func (z *Z3Optimizer) OptimizeDocumentSelection(
	ctx context.Context,
	docs []types.ScoredDocument,
	pairs []DocumentPair,
	maxTokens int,
	maxDocs int) (*OptimizeResult, error) {

	totalTimer := timing.Start()

	// Build SMT-LIB2 model
	smtModel := z.buildSMTModel(docs, pairs, maxTokens, maxDocs)

	// Create context with timeout
	ctxTimeout, cancel := context.WithTimeout(ctx, time.Duration(z.timeoutMs)*time.Millisecond)
	defer cancel()

	// Run Z3 with the model
	z3Timer := timing.Start()
	result, err := z.runZ3(ctxTimeout, smtModel)
	if err != nil {
		return nil, fmt.Errorf("Z3 execution failed: %w", err)
	}
	z3Us := z3Timer.Us()

	// Set timing information with microsecond precision
	totalUs := totalTimer.Us()
	result.SolveTimeUs = z3Us
	result.SolveTimeMs = int(float64(totalUs) / 1_000.0) // Total wall time for legacy compatibility
	result.VariableCount = len(docs) + len(pairs)
	result.ConstraintCount = z.countConstraints(docs, pairs, maxTokens > 0, maxDocs > 0)

	return result, nil
}

// buildSMTModel creates the SMT-LIB2 model string
func (z *Z3Optimizer) buildSMTModel(docs []types.ScoredDocument, pairs []DocumentPair, maxTokens int, maxDocs int) string {
	var sb strings.Builder

	// SMT-LIB2 header
	sb.WriteString("(set-logic QF_LIA)\n")
	sb.WriteString(fmt.Sprintf("; Generated by ContextLite Z3 optimizer\n"))
	sb.WriteString(fmt.Sprintf("; Variables: %d documents + %d pairs = %d total\n", len(docs), len(pairs), len(docs)+len(pairs)))
	
	// Calculate constraint count (excluding objective equality per policy)
	constraintCount := 2*len(docs) + 2*len(pairs) + 3*len(pairs)
	if maxTokens > 0 {
		constraintCount++
	}
	if maxDocs > 0 {
		constraintCount++
	}
	sb.WriteString(fmt.Sprintf("; Constraints: %d (objective equality not counted per policy)\n", constraintCount))
	sb.WriteString("\n")

	// Decision variables: x_i for each document
	sb.WriteString("; Document selection variables\n")
	for i := range docs {
		sb.WriteString(fmt.Sprintf("(declare-fun x%d () Int)\n", i))
		sb.WriteString(fmt.Sprintf("(assert (>= x%d 0))\n", i))
		sb.WriteString(fmt.Sprintf("(assert (<= x%d 1))\n", i))
	}
	sb.WriteString("\n")

	// Co-selection variables: y_ij for top-M pairs
	if len(pairs) > 0 {
		sb.WriteString("; Co-selection variables for top-M pairs\n")
		for _, pair := range pairs {
			varName := fmt.Sprintf("y%d_%d", pair.DocI, pair.DocJ)
			sb.WriteString(fmt.Sprintf("(declare-fun %s () Int)\n", varName))
			sb.WriteString(fmt.Sprintf("(assert (>= %s 0))\n", varName))
			sb.WriteString(fmt.Sprintf("(assert (<= %s 1))\n", varName))
		}
		sb.WriteString("\n")
	}

	// Budget constraint: Σ t_i * x_i ≤ B
	if maxTokens > 0 {
		sb.WriteString("; Token budget constraint\n")
		sb.WriteString("(assert (<= (+")
		for i, doc := range docs {
			sb.WriteString(fmt.Sprintf(" (* %d x%d)", doc.Document.TokenCount, i))
		}
		sb.WriteString(fmt.Sprintf(") %d))\n\n", maxTokens))
	}

	// Cardinality constraint: Σ x_i ≤ D_max
	if maxDocs > 0 {
		sb.WriteString("; Document count constraint\n")
		sb.WriteString("(assert (<= (+")
		for i := range docs {
			sb.WriteString(fmt.Sprintf(" x%d", i))
		}
		sb.WriteString(fmt.Sprintf(") %d))\n\n", maxDocs))
	}

	// Linking constraints for co-selection variables
	if len(pairs) > 0 {
		sb.WriteString("; Linking constraints: y_ij ↔ x_i ∧ x_j\n")
		for _, pair := range pairs {
			varName := fmt.Sprintf("y%d_%d", pair.DocI, pair.DocJ)
			// y_ij ≤ x_i
			sb.WriteString(fmt.Sprintf("(assert (<= %s x%d))\n", varName, pair.DocI))
			// y_ij ≤ x_j  
			sb.WriteString(fmt.Sprintf("(assert (<= %s x%d))\n", varName, pair.DocJ))
			// y_ij ≥ x_i + x_j - 1  ⟺  x_i + x_j - y_ij ≤ 1
			sb.WriteString(fmt.Sprintf("(assert (<= (+ x%d x%d (* -1 %s)) 1))\n", 
				pair.DocI, pair.DocJ, varName))
		}
		sb.WriteString("\n")
	}

	// Objective function: Σ v_i * x_i - Σ r_ij * y_ij + Σ c_ij * y_ij
	sb.WriteString("; Objective function\n")
	sb.WriteString("(declare-fun obj () Int)\n")
	sb.WriteString("(assert (= obj (+")

	// Per-document utility terms
	for i, doc := range docs {
		// Scale utility score to integer (set-independent features only)
		scaledUtility := int(doc.UtilityScore * float64(z.integerScale))
		sb.WriteString(fmt.Sprintf(" (* %d x%d)", scaledUtility, i))
	}

	// Pairwise penalty/bonus terms
	for _, pair := range pairs {
		varName := fmt.Sprintf("y%d_%d", pair.DocI, pair.DocJ)
		// Net effect: coherence_bonus - redundancy_penalty
		netEffect := int((pair.CoherenceBonus - pair.RedundancyPenalty) * float64(z.integerScale))
		if netEffect != 0 {
			sb.WriteString(fmt.Sprintf(" (* %d %s)", netEffect, varName))
		}
	}

	sb.WriteString(")))\n\n")

	// Optimization directive
	sb.WriteString("(maximize obj)\n")
	sb.WriteString("(check-sat)\n")
	sb.WriteString("(get-objectives)\n")
	sb.WriteString("(get-model)\n")

	return sb.String()
}

// runZ3 executes Z3 with the SMT model and parses the result
func (z *Z3Optimizer) runZ3(ctx context.Context, smtModel string) (*OptimizeResult, error) {
	// Create Z3 command
	cmd := exec.CommandContext(ctx, z.z3Path, "-in")
	cmd.Stdin = strings.NewReader(smtModel)

	// Run Z3 and capture output
	output, err := cmd.Output()
	
	if err != nil {
		// Check if it was a timeout
		if ctx.Err() == context.DeadlineExceeded {
			return &OptimizeResult{
				Status:   "unknown",
				TimedOut: true,
			}, nil
		}
		return nil, fmt.Errorf("Z3 execution error: %w", err)
	}

	// Parse Z3 output
	return z.parseZ3Output(string(output))
}

// parseZ3Output parses Z3 output to extract the solution
func (z *Z3Optimizer) parseZ3Output(output string) (*OptimizeResult, error) {
	result := &OptimizeResult{}

	lines := strings.Split(output, "\n")
	
	// Parse status (first line should be "sat", "unsat", or "unknown")
	if len(lines) > 0 {
		result.Status = strings.TrimSpace(lines[0])
	}

	if result.Status == "unsat" {
		return result, nil
	}

	if result.Status == "unknown" {
		result.TimedOut = true
		return result, nil
	}

	// Parse objectives (look for multi-line objectives section)
	objectiveRegex := regexp.MustCompile(`\(obj\s+(-?\d+)\)`)
	for _, line := range lines {
		if matches := objectiveRegex.FindStringSubmatch(line); len(matches) > 1 {
			if objVal, err := strconv.Atoi(matches[1]); err == nil {
				result.ObjectiveValue = objVal
			}
		}
	}

	// Parse model (extract x_i variable assignments)
	// Z3 outputs multi-line define-fun statements, so we need to handle them differently
	varHeaderRegex := regexp.MustCompile(`\(define-fun\s+x(\d+)\s+\(\)\s+Int`)
	selectedDocs := make(map[int]bool)
	
	for i, line := range lines {
		if matches := varHeaderRegex.FindStringSubmatch(line); len(matches) > 1 {
			if docIdx, err := strconv.Atoi(matches[1]); err == nil {
				// Look for the value on the next line
				if i+1 < len(lines) {
					valueLine := strings.TrimSpace(lines[i+1])
					// Remove closing parenthesis if present
					valueLine = strings.TrimSuffix(valueLine, ")")
					if value, err := strconv.Atoi(valueLine); err == nil && value == 1 {
						selectedDocs[docIdx] = true
					}
				}
			}
		}
	}

	// Convert map to sorted slice
	for docIdx := range selectedDocs {
		result.SelectedDocs = append(result.SelectedDocs, docIdx)
	}

	return result, nil
}

// countConstraints estimates the number of constraints in the model
func (z *Z3Optimizer) countConstraints(docs []types.ScoredDocument, pairs []DocumentPair, hasBudget, hasCardinality bool) int {
	count := 0
	
	// Variable bounds (2 per variable: x_i >= 0 and x_i <= 1)
	count += 2 * len(docs)       // Document variables
	count += 2 * len(pairs)      // Co-selection variables
	
	// Budget constraint
	if hasBudget {
		count++
	}
	
	// Cardinality constraint
	if hasCardinality {
		count++
	}
	
	// Linking constraints (3 per pair)
	count += 3 * len(pairs)
	
	// Objective definition
	count++
	
	return count
}

// DocumentPair represents a pair of documents with similarity metrics
type DocumentPair struct {
	DocI             int
	DocJ             int
	Similarity       float64
	RedundancyPenalty float64
	CoherenceBonus   float64
}

// CheckZ3Available verifies that Z3 is available and working
func CheckZ3Available(z3Path string) error {
	cmd := exec.Command(z3Path, "-version")
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("Z3 not found at %s: %w", z3Path, err)
	}
	
	if !strings.Contains(string(output), "Z3") {
		return fmt.Errorf("invalid Z3 binary at %s", z3Path)
	}
	
	return nil
}
