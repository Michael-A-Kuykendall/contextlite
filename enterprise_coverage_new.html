
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>enterprise: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">contextlite/internal/enterprise/mcp.go (47.5%)</option>
				
				<option value="file1">contextlite/internal/enterprise/tenant.go (81.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package enterprise

import (
        "fmt"
        "time"
        "database/sql"
        "encoding/json"
        "crypto/rand"
        "encoding/hex"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "net/http"
        "contextlite/pkg/types"
)

// MCPServerConfig represents an MCP server configuration (different from MCPServer for API compatibility)
type MCPServerConfig struct {
        ID        string                 `json:"id"`
        Name      string                 `json:"name"`
        Type      string                 `json:"type"`
        Endpoint  string                 `json:"endpoint"`
        Config    map[string]interface{} `json:"config"`
        CreatedAt time.Time              `json:"created_at"`
}
// MCPServer represents a custom Model Context Protocol server
type MCPServer struct {
        ID          string    `json:"id"`
        TenantID    string    `json:"tenant_id"`
        Name        string    `json:"name"`
        Description string    `json:"description"`
        Endpoint    string    `json:"endpoint"`
        Protocol    string    `json:"protocol"`    // "websocket", "stdio", "http"
        Config      MCPConfig `json:"config"`
        Status      string    `json:"status"`      // "active", "inactive", "error"
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

// MCPConfig contains server-specific configuration
type MCPConfig struct {
        Authentication map[string]interface{} `json:"authentication"`
        Capabilities   []string               `json:"capabilities"`
        Tools          []MCPTool              `json:"tools"`
        Resources      []MCPResource          `json:"resources"`
        Settings       map[string]interface{} `json:"settings"`
}

// MCPTool represents a tool exposed by the MCP server
type MCPTool struct {
        Name        string                 `json:"name"`
        Description string                 `json:"description"`
        Parameters  map[string]interface{} `json:"parameters"`
        Handler     string                 `json:"handler"`
}

// MCPResource represents a resource exposed by the MCP server
type MCPResource struct {
        URI         string                 `json:"uri"`
        Name        string                 `json:"name"`
        Description string                 `json:"description"`
        MimeType    string                 `json:"mime_type"`
        Metadata    map[string]interface{} `json:"metadata"`
}

// MCPManager handles custom MCP server operations
type MCPManager struct {
        db          *sql.DB
        featureGate types.FeatureGate
}

// NewMCPManager creates a new MCP manager
func NewMCPManager(db *sql.DB, featureGate types.FeatureGate) *MCPManager <span class="cov8" title="1">{
        return &amp;MCPManager{
                db:          db,
                featureGate: featureGate,
        }
}</span>

// CreateMCPServer creates a new custom MCP server for a tenant
func (mm *MCPManager) CreateMCPServer(tenantID, name, description, endpoint, protocol string, config MCPConfig) (*MCPServer, error) <span class="cov8" title="1">{
        // Validate enterprise license for custom MCP servers
        if err := mm.featureGate.ValidateCustomMCP(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">serverID, err := generateServerID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate server ID: %w", err)
        }</span>

        <span class="cov8" title="1">server := &amp;MCPServer{
                ID:          serverID,
                TenantID:    tenantID,
                Name:        name,
                Description: description,
                Endpoint:    endpoint,
                Protocol:    protocol,
                Config:      config,
                Status:      "inactive",
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        if err := mm.storeMCPServer(server); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store MCP server: %w", err)
        }</span>

        <span class="cov8" title="1">return server, nil</span>
}

// GetMCPServer retrieves an MCP server by ID
func (mm *MCPManager) GetMCPServer(serverID string) (*MCPServer, error) <span class="cov8" title="1">{
        query := `
                SELECT id, tenant_id, name, description, endpoint, protocol, 
                       config, status, created_at, updated_at
                FROM mcp_servers WHERE id = ?
        `
        
        row := mm.db.QueryRow(query, serverID)
        
        server := &amp;MCPServer{}
        var configJSON string
        
        err := row.Scan(
                &amp;server.ID, &amp;server.TenantID, &amp;server.Name, &amp;server.Description,
                &amp;server.Endpoint, &amp;server.Protocol, &amp;configJSON, &amp;server.Status,
                &amp;server.CreatedAt, &amp;server.UpdatedAt,
        )
        
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("MCP server not found: %w", err)
        }</span>
        
        <span class="cov8" title="1">if err := json.Unmarshal([]byte(configJSON), &amp;server.Config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse MCP config: %w", err)
        }</span>
        
        <span class="cov8" title="1">return server, nil</span>
}

// ListMCPServers returns all MCP servers for a tenant
func (mm *MCPManager) ListMCPServers(tenantID string) ([]*MCPServer, error) <span class="cov8" title="1">{
        query := `
                SELECT id, tenant_id, name, description, endpoint, protocol,
                       config, status, created_at, updated_at
                FROM mcp_servers WHERE tenant_id = ? ORDER BY created_at DESC
        `
        
        rows, err := mm.db.Query(query, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query MCP servers: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        
        var servers []*MCPServer
        for rows.Next() </span><span class="cov8" title="1">{
                server := &amp;MCPServer{}
                var configJSON string
                
                err := rows.Scan(
                        &amp;server.ID, &amp;server.TenantID, &amp;server.Name, &amp;server.Description,
                        &amp;server.Endpoint, &amp;server.Protocol, &amp;configJSON, &amp;server.Status,
                        &amp;server.CreatedAt, &amp;server.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan MCP server: %w", err)
                }</span>
                
                <span class="cov8" title="1">if err := json.Unmarshal([]byte(configJSON), &amp;server.Config); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse MCP config: %w", err)
                }</span>
                
                <span class="cov8" title="1">servers = append(servers, server)</span>
        }
        
        <span class="cov8" title="1">return servers, nil</span>
}

// UpdateMCPServer updates an MCP server configuration
func (mm *MCPManager) UpdateMCPServer(serverID string, config MCPConfig) error <span class="cov0" title="0">{
        configJSON, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>
        
        <span class="cov0" title="0">query := `
                UPDATE mcp_servers SET config = ?, updated_at = ? WHERE id = ?
        `
        
        _, err = mm.db.Exec(query, string(configJSON), time.Now(), serverID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update MCP server: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// SetMCPServerStatus updates the status of an MCP server
func (mm *MCPManager) SetMCPServerStatus(serverID, status string) error <span class="cov0" title="0">{
        query := `
                UPDATE mcp_servers SET status = ?, updated_at = ? WHERE id = ?
        `
        
        _, err := mm.db.Exec(query, status, time.Now(), serverID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update MCP server status: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// DeleteMCPServer removes an MCP server
func (mm *MCPManager) DeleteMCPServer(serverID string) error <span class="cov0" title="0">{
        _, err := mm.db.Exec("DELETE FROM mcp_servers WHERE id = ?", serverID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete MCP server: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// DeployMCPServer activates an MCP server for use
func (mm *MCPManager) DeployMCPServer(serverID string) error <span class="cov0" title="0">{
        server, err := mm.GetMCPServer(serverID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server not found: %w", err)
        }</span>
        
        // Convert to MCPServerConfig for deployment logic
        <span class="cov0" title="0">deployServer := &amp;MCPServerConfig{
                ID:        server.ID,
                Name:      server.Name,
                Type:      server.Protocol, // Use protocol as type for simplicity
                Endpoint:  server.Endpoint,
                Config:    server.Config.Settings, // Use settings as config
                CreatedAt: server.CreatedAt,
        }
        
        // Validate configuration before deployment
        if err := mm.validateMCPConfig(deployServer.Config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid MCP configuration: %w", err)
        }</span>
        
        // Update status to deploying
        <span class="cov0" title="0">if err := mm.SetMCPServerStatus(serverID, "deploying"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update status: %w", err)
        }</span>
        
        // Generate deployment configuration
        <span class="cov0" title="0">deployConfig, err := mm.generateDeploymentConfig(deployServer)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate deployment config: %w", err)
        }</span>
        
        // Deploy based on server type
        <span class="cov0" title="0">var deployErr error
        switch deployServer.Type </span>{
        case "http", "jira":<span class="cov0" title="0">
                deployErr = mm.deployJiraServer(deployServer, deployConfig)</span>
        case "websocket", "slack":<span class="cov0" title="0">
                deployErr = mm.deploySlackServer(deployServer, deployConfig)</span>
        case "stdio", "github":<span class="cov0" title="0">
                deployErr = mm.deployGithubServer(deployServer, deployConfig)</span>
        case "custom":<span class="cov0" title="0">
                deployErr = mm.deployCustomServer(deployServer, deployConfig)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported server type: %s", deployServer.Type)</span>
        }
        
        <span class="cov0" title="0">if deployErr != nil </span><span class="cov0" title="0">{
                mm.SetMCPServerStatus(serverID, "failed")
                return fmt.Errorf("deployment failed: %w", deployErr)
        }</span>
        
        // Health check with retry
        <span class="cov0" title="0">if err := mm.healthCheckWithRetry(deployServer.Endpoint, 30*time.Second); err != nil </span><span class="cov0" title="0">{
                mm.SetMCPServerStatus(serverID, "unhealthy")
                return fmt.Errorf("health check failed: %w", err)
        }</span>
        
        // Mark as active
        <span class="cov0" title="0">if err := mm.SetMCPServerStatus(serverID, "active"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update final status: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// CreateJiraIntegration creates a custom MCP server for Jira integration
func (mm *MCPManager) CreateJiraIntegration(tenantID, jiraURL, apiToken string) (*MCPServer, error) <span class="cov8" title="1">{
        // Validate enterprise license for custom integrations
        if err := mm.featureGate.ValidateCustomMCP(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">config := MCPConfig{
                Authentication: map[string]interface{}{
                        "type":      "bearer",
                        "token":     apiToken,
                        "base_url":  jiraURL,
                },
                Capabilities: []string{"issues", "projects", "search"},
                Tools: []MCPTool{
                        {
                                Name:        "search_issues",
                                Description: "Search Jira issues with JQL",
                                Parameters: map[string]interface{}{
                                        "jql":      map[string]interface{}{"type": "string", "required": true},
                                        "fields":   map[string]interface{}{"type": "array", "required": false},
                                        "max_results": map[string]interface{}{"type": "number", "default": 50},
                                },
                                Handler: "jira.search_issues",
                        },
                        {
                                Name:        "get_issue",
                                Description: "Get detailed information about a Jira issue",
                                Parameters: map[string]interface{}{
                                        "issue_key": map[string]interface{}{"type": "string", "required": true},
                                },
                                Handler: "jira.get_issue",
                        },
                },
                Resources: []MCPResource{
                        {
                                URI:         fmt.Sprintf("jira://%s/issues", tenantID),
                                Name:        "Jira Issues",
                                Description: "Access to Jira issues and projects",
                                MimeType:    "application/json",
                        },
                },
                Settings: map[string]interface{}{
                        "rate_limit": 100,
                        "timeout":    30,
                },
        }
        
        return mm.CreateMCPServer(tenantID, "Jira Integration", "Custom Jira MCP server", 
                fmt.Sprintf("%s/rest/api/2", jiraURL), "http", config)</span>
}

// CreateSlackIntegration creates a custom MCP server for Slack integration
func (mm *MCPManager) CreateSlackIntegration(tenantID, botToken, appToken string) (*MCPServer, error) <span class="cov8" title="1">{
        // Validate enterprise license for custom integrations
        if err := mm.featureGate.ValidateCustomMCP(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">config := MCPConfig{
                Authentication: map[string]interface{}{
                        "bot_token": botToken,
                        "app_token": appToken,
                },
                Capabilities: []string{"messages", "channels", "users"},
                Tools: []MCPTool{
                        {
                                Name:        "send_message",
                                Description: "Send a message to a Slack channel",
                                Parameters: map[string]interface{}{
                                        "channel": map[string]interface{}{"type": "string", "required": true},
                                        "text":    map[string]interface{}{"type": "string", "required": true},
                                },
                                Handler: "slack.send_message",
                        },
                        {
                                Name:        "search_messages",
                                Description: "Search Slack messages",
                                Parameters: map[string]interface{}{
                                        "query": map[string]interface{}{"type": "string", "required": true},
                                        "sort":  map[string]interface{}{"type": "string", "default": "timestamp"},
                                },
                                Handler: "slack.search_messages",
                        },
                },
                Resources: []MCPResource{
                        {
                                URI:         fmt.Sprintf("slack://%s/messages", tenantID),
                                Name:        "Slack Messages",
                                Description: "Access to Slack conversations",
                                MimeType:    "application/json",
                        },
                },
        }
        
        return mm.CreateMCPServer(tenantID, "Slack Integration", "Custom Slack MCP server",
                "wss://wss.slack.com/websocket", "websocket", config)</span>
}

// storeMCPServer persists MCP server configuration to database
func (mm *MCPManager) storeMCPServer(server *MCPServer) error <span class="cov8" title="1">{
        configJSON, err := json.Marshal(server.Config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>
        
        <span class="cov8" title="1">query := `
                INSERT INTO mcp_servers (
                        id, tenant_id, name, description, endpoint, protocol,
                        config, status, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `
        
        _, err = mm.db.Exec(query,
                server.ID, server.TenantID, server.Name, server.Description,
                server.Endpoint, server.Protocol, string(configJSON), server.Status,
                server.CreatedAt, server.UpdatedAt,
        )
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store MCP server: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// generateServerID creates a unique server identifier
func generateServerID() (string, error) <span class="cov8" title="1">{
        bytes := make([]byte, 16)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return "mcp_" + hex.EncodeToString(bytes)[:16], nil</span>
}

// validateMCPConfig validates MCP server configuration
func (mm *MCPManager) validateMCPConfig(config map[string]interface{}) error <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration cannot be nil")
        }</span>
        <span class="cov8" title="1">return nil</span> // Basic validation for now
}

// generateDeploymentConfig creates deployment-specific configuration
func (mm *MCPManager) generateDeploymentConfig(server *MCPServerConfig) (map[string]interface{}, error) <span class="cov8" title="1">{
        config := make(map[string]interface{})
        
        // Base configuration
        config["server_id"] = server.ID
        config["server_name"] = server.Name
        config["server_type"] = server.Type
        config["endpoint"] = server.Endpoint
        config["created_at"] = server.CreatedAt
        
        // Parse port from endpoint
        if strings.Contains(server.Endpoint, ":") </span><span class="cov8" title="1">{
                parts := strings.Split(server.Endpoint, ":")
                if len(parts) &gt; 2 </span><span class="cov8" title="1">{
                        config["port"] = parts[2]
                }</span>
        }
        
        // Environment variables
        <span class="cov8" title="1">config["env"] = map[string]string{
                "MCP_SERVER_ID":   server.ID,
                "MCP_SERVER_NAME": server.Name,
                "NODE_ENV":        "production",
        }
        
        if port, ok := config["port"].(string); ok </span><span class="cov8" title="1">{
                config["env"].(map[string]string)["MCP_PORT"] = port
        }</span>
        
        // Merge user configuration
        <span class="cov8" title="1">for key, value := range server.Config </span><span class="cov8" title="1">{
                config[key] = value
        }</span>
        
        <span class="cov8" title="1">return config, nil</span>
}

// deployJiraServer deploys a Jira integration MCP server
func (mm *MCPManager) deployJiraServer(server *MCPServerConfig, config map[string]interface{}) error <span class="cov0" title="0">{
        // Create server directory
        serverDir := filepath.Join("./mcp_servers", server.ID)
        if err := os.MkdirAll(serverDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create server directory: %w", err)
        }</span>
        
        // Generate basic Jira MCP server code
        <span class="cov0" title="0">serverCode := mm.generateJiraMCPCode(config)
        packageJSON := mm.generatePackageJSON(server.Name, config)
        
        // Write server files
        files := map[string]string{
                "package.json": packageJSON,
                "index.js":     serverCode,
                "config.json":  mm.generateConfigJSON(config),
        }
        
        for filename, content := range files </span><span class="cov0" title="0">{
                filePath := filepath.Join(serverDir, filename)
                if err := os.WriteFile(filePath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write %s: %w", filename, err)
                }</span>
        }
        
        // Install dependencies and start server
        <span class="cov0" title="0">return mm.startNodeServer(serverDir, config)</span>
}

// deploySlackServer deploys a Slack bot MCP server
func (mm *MCPManager) deploySlackServer(server *MCPServerConfig, config map[string]interface{}) error <span class="cov0" title="0">{
        serverDir := filepath.Join("./mcp_servers", server.ID)
        if err := os.MkdirAll(serverDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create server directory: %w", err)
        }</span>
        
        <span class="cov0" title="0">serverCode := mm.generateSlackMCPCode(config)
        packageJSON := mm.generatePackageJSON(server.Name, config)
        
        files := map[string]string{
                "package.json": packageJSON,
                "index.js":     serverCode,
                "config.json":  mm.generateConfigJSON(config),
        }
        
        for filename, content := range files </span><span class="cov0" title="0">{
                filePath := filepath.Join(serverDir, filename)
                if err := os.WriteFile(filePath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write %s: %w", filename, err)
                }</span>
        }
        
        <span class="cov0" title="0">return mm.startNodeServer(serverDir, config)</span>
}

// deployGithubServer deploys a GitHub integration MCP server
func (mm *MCPManager) deployGithubServer(server *MCPServerConfig, config map[string]interface{}) error <span class="cov8" title="1">{
        return fmt.Errorf("GitHub MCP server deployment not yet implemented")
}</span>

// deployCustomServer deploys a custom MCP server
func (mm *MCPManager) deployCustomServer(server *MCPServerConfig, config map[string]interface{}) error <span class="cov8" title="1">{
        return fmt.Errorf("custom MCP server deployment not yet implemented")
}</span>

// healthCheckWithRetry performs health check with exponential backoff
func (mm *MCPManager) healthCheckWithRetry(endpoint string, timeout time.Duration) error <span class="cov8" title="1">{
        start := time.Now()
        backoff := 1 * time.Second
        
        for time.Since(start) &lt; timeout </span><span class="cov8" title="1">{
                if err := mm.healthCheck(endpoint); err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                
                <span class="cov8" title="1">time.Sleep(backoff)
                backoff = time.Duration(float64(backoff) * 1.5)
                if backoff &gt; 10*time.Second </span><span class="cov0" title="0">{
                        backoff = 10 * time.Second
                }</span>
        }
        
        <span class="cov8" title="1">return fmt.Errorf("health check timeout after %v", timeout)</span>
}

// healthCheck performs a simple HTTP health check
func (mm *MCPManager) healthCheck(endpoint string) error <span class="cov8" title="1">{
        client := &amp;http.Client{Timeout: 5 * time.Second}
        resp, err := client.Get(endpoint + "/health")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("health check returned status %d", resp.StatusCode)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// startNodeServer installs dependencies and starts a Node.js MCP server
func (mm *MCPManager) startNodeServer(serverDir string, config map[string]interface{}) error <span class="cov0" title="0">{
        // Install npm dependencies
        npmInstallCmd := exec.Command("npm", "install")
        npmInstallCmd.Dir = serverDir
        if err := npmInstallCmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("npm install failed: %w", err)
        }</span>
        
        // Start server in background
        <span class="cov0" title="0">startCmd := exec.Command("npm", "start")
        startCmd.Dir = serverDir
        
        // Set environment variables
        if env, ok := config["env"].(map[string]string); ok </span><span class="cov0" title="0">{
                for key, value := range env </span><span class="cov0" title="0">{
                        startCmd.Env = append(startCmd.Env, fmt.Sprintf("%s=%s", key, value))
                }</span>
        }
        
        <span class="cov0" title="0">if err := startCmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start server: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// generateJiraMCPCode generates basic Node.js code for Jira MCP server
func (mm *MCPManager) generateJiraMCPCode(config map[string]interface{}) string <span class="cov8" title="1">{
        return `const express = require('express');
const app = express();
const port = process.env.MCP_PORT || 3000;

app.use(express.json());

// Health check endpoint
app.get('/health', (req, res) =&gt; {
  res.json({ status: 'healthy', server: 'jira-mcp' });
});

// MCP endpoints
app.post('/mcp/tools/search_issues', (req, res) =&gt; {
  // TODO: Implement Jira issue search
  res.json({ message: 'Jira search not implemented' });
});

app.listen(port, () =&gt; {
  console.log('Jira MCP server running on port', port);
});`
}</span>

// generateSlackMCPCode generates basic Node.js code for Slack MCP server
func (mm *MCPManager) generateSlackMCPCode(config map[string]interface{}) string <span class="cov8" title="1">{
        return `const express = require('express');
const app = express();
const port = process.env.MCP_PORT || 3000;

app.use(express.json());

// Health check endpoint
app.get('/health', (req, res) =&gt; {
  res.json({ status: 'healthy', server: 'slack-mcp' });
});

// MCP endpoints
app.post('/mcp/tools/send_message', (req, res) =&gt; {
  // TODO: Implement Slack message sending
  res.json({ message: 'Slack integration not implemented' });
});

app.listen(port, () =&gt; {
  console.log('Slack MCP server running on port', port);
});`
}</span>

// generatePackageJSON generates package.json for Node.js MCP server
func (mm *MCPManager) generatePackageJSON(name string, config map[string]interface{}) string <span class="cov8" title="1">{
        return fmt.Sprintf(`{
  "name": "%s",
  "version": "1.0.0",
  "description": "Generated MCP server",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  },
  "dependencies": {
    "express": "^4.18.0"
  }
}`, strings.ToLower(strings.ReplaceAll(name, " ", "-")))
}</span>

// generateConfigJSON generates config.json for MCP server
func (mm *MCPManager) generateConfigJSON(config map[string]interface{}) string <span class="cov8" title="1">{
        configBytes, _ := json.MarshalIndent(config, "", "  ")
        return string(configBytes)
}</span>

// InitMCPSchema creates the MCP servers table
func InitMCPSchema(db *sql.DB) error <span class="cov8" title="1">{
        schema := `
                CREATE TABLE IF NOT EXISTS mcp_servers (
                        id TEXT PRIMARY KEY,
                        tenant_id TEXT NOT NULL,
                        name TEXT NOT NULL,
                        description TEXT,
                        endpoint TEXT NOT NULL,
                        protocol TEXT NOT NULL,
                        config TEXT NOT NULL,
                        status TEXT DEFAULT 'inactive',
                        created_at DATETIME NOT NULL,
                        updated_at DATETIME NOT NULL,
                        FOREIGN KEY (tenant_id) REFERENCES tenants(id)
                );
                
                CREATE INDEX IF NOT EXISTS idx_mcp_servers_tenant_id ON mcp_servers(tenant_id);
                CREATE INDEX IF NOT EXISTS idx_mcp_servers_status ON mcp_servers(status);
        `
        
        _, err := db.Exec(schema)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MCP schema: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package enterprise

import (
        "fmt"
        "time"
        "database/sql"
        "crypto/rand"
        "encoding/hex"
        "os"
        "path/filepath"
        "contextlite/pkg/types"
)

// TenantConfig represents a multi-tenant workspace configuration
type TenantConfig struct {
        ID          string    `json:"id"`
        Name        string    `json:"name"`
        Domain      string    `json:"domain"`      // e.g., "acme-corp"
        OrgID       string    `json:"org_id"`     // Parent organization
        DatabaseURL string    `json:"database_url"`
        CreatedAt   time.Time `json:"created_at"`
        Settings    TenantSettings `json:"settings"`
}

// TenantSettings contains tenant-specific configuration
type TenantSettings struct {
        MaxUsers       int               `json:"max_users"`
        MaxDocuments   int               `json:"max_documents"`
        RetentionDays  int               `json:"retention_days"`
        AllowedDomains []string          `json:"allowed_domains"`
        SSOEnabled     bool              `json:"sso_enabled"`
        SSOProvider    string            `json:"sso_provider"`
        CustomMCP      bool              `json:"custom_mcp"`
        Analytics      bool              `json:"analytics"`
        Settings       map[string]interface{} `json:"settings,omitempty"` // Additional settings
}

// TenantManager handles multi-tenant operations
type TenantManager struct {
        db          *sql.DB
        featureGate types.FeatureGate
}

// NewTenantManager creates a new tenant manager
func NewTenantManager(db *sql.DB, featureGate types.FeatureGate) *TenantManager <span class="cov8" title="1">{
        return &amp;TenantManager{
                db:          db,
                featureGate: featureGate,
        }
}</span>

// CreateTenant creates a new isolated tenant workspace
func (tm *TenantManager) CreateTenant(name, domain, orgID string, settings TenantSettings) (*TenantConfig, error) <span class="cov8" title="1">{
        // Validate enterprise license for multi-tenant features
        if err := tm.featureGate.ValidateMultiTenant(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tenantID, err := generateTenantID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate tenant ID: %w", err)
        }</span>

        // Create isolated database for tenant
        <span class="cov8" title="1">dbURL := fmt.Sprintf("contextlite_tenant_%s.db", tenantID)
        
        tenant := &amp;TenantConfig{
                ID:          tenantID,
                Name:        name,
                Domain:      domain,
                OrgID:       orgID,
                DatabaseURL: dbURL,
                CreatedAt:   time.Now(),
                Settings:    settings,
        }

        // Initialize tenant database schema
        if err := tm.initTenantDatabase(tenant); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize tenant database: %w", err)
        }</span>

        // Store tenant configuration
        <span class="cov8" title="1">if err := tm.storeTenantConfig(tenant); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store tenant config: %w", err)
        }</span>

        <span class="cov8" title="1">return tenant, nil</span>
}

// GetTenant retrieves tenant configuration by ID
func (tm *TenantManager) GetTenant(tenantID string) (*TenantConfig, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, domain, org_id, database_url, created_at,
                       max_users, max_documents, retention_days, sso_enabled, 
                       sso_provider, custom_mcp, analytics
                FROM tenants WHERE id = ?
        `
        
        row := tm.db.QueryRow(query, tenantID)
        
        tenant := &amp;TenantConfig{}
        err := row.Scan(
                &amp;tenant.ID, &amp;tenant.Name, &amp;tenant.Domain, &amp;tenant.OrgID,
                &amp;tenant.DatabaseURL, &amp;tenant.CreatedAt,
                &amp;tenant.Settings.MaxUsers, &amp;tenant.Settings.MaxDocuments,
                &amp;tenant.Settings.RetentionDays, &amp;tenant.Settings.SSOEnabled,
                &amp;tenant.Settings.SSOProvider, &amp;tenant.Settings.CustomMCP,
                &amp;tenant.Settings.Analytics,
        )
        
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("tenant not found: %w", err)
        }</span>
        
        <span class="cov8" title="1">return tenant, nil</span>
}

// GetTenantByDomain retrieves tenant by domain name
func (tm *TenantManager) GetTenantByDomain(domain string) (*TenantConfig, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, domain, org_id, database_url, created_at,
                       max_users, max_documents, retention_days, sso_enabled, 
                       sso_provider, custom_mcp, analytics
                FROM tenants WHERE domain = ?
        `
        
        row := tm.db.QueryRow(query, domain)
        
        tenant := &amp;TenantConfig{}
        err := row.Scan(
                &amp;tenant.ID, &amp;tenant.Name, &amp;tenant.Domain, &amp;tenant.OrgID,
                &amp;tenant.DatabaseURL, &amp;tenant.CreatedAt,
                &amp;tenant.Settings.MaxUsers, &amp;tenant.Settings.MaxDocuments,
                &amp;tenant.Settings.RetentionDays, &amp;tenant.Settings.SSOEnabled,
                &amp;tenant.Settings.SSOProvider, &amp;tenant.Settings.CustomMCP,
                &amp;tenant.Settings.Analytics,
        )
        
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("tenant not found for domain %s: %w", domain, err)
        }</span>
        
        <span class="cov8" title="1">return tenant, nil</span>
}

// ListTenants returns all tenants for an organization
func (tm *TenantManager) ListTenants(orgID string) ([]*TenantConfig, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, domain, org_id, database_url, created_at,
                       max_users, max_documents, retention_days, sso_enabled, 
                       sso_provider, custom_mcp, analytics
                FROM tenants WHERE org_id = ? ORDER BY created_at DESC
        `
        
        rows, err := tm.db.Query(query, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query tenants: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        
        var tenants []*TenantConfig
        for rows.Next() </span><span class="cov8" title="1">{
                tenant := &amp;TenantConfig{}
                err := rows.Scan(
                        &amp;tenant.ID, &amp;tenant.Name, &amp;tenant.Domain, &amp;tenant.OrgID,
                        &amp;tenant.DatabaseURL, &amp;tenant.CreatedAt,
                        &amp;tenant.Settings.MaxUsers, &amp;tenant.Settings.MaxDocuments,
                        &amp;tenant.Settings.RetentionDays, &amp;tenant.Settings.SSOEnabled,
                        &amp;tenant.Settings.SSOProvider, &amp;tenant.Settings.CustomMCP,
                        &amp;tenant.Settings.Analytics,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan tenant: %w", err)
                }</span>
                <span class="cov8" title="1">tenants = append(tenants, tenant)</span>
        }
        
        <span class="cov8" title="1">return tenants, nil</span>
}

// UpdateTenantSettings updates tenant configuration
func (tm *TenantManager) UpdateTenantSettings(tenantID string, settings TenantSettings) error <span class="cov8" title="1">{
        query := `
                UPDATE tenants SET 
                max_users = ?, max_documents = ?, retention_days = ?,
                sso_enabled = ?, sso_provider = ?, custom_mcp = ?, analytics = ?
                WHERE id = ?
        `
        
        _, err := tm.db.Exec(query,
                settings.MaxUsers, settings.MaxDocuments, settings.RetentionDays,
                settings.SSOEnabled, settings.SSOProvider, settings.CustomMCP,
                settings.Analytics, tenantID,
        )
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update tenant settings: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// DeleteTenant removes a tenant and its data (careful!)
func (tm *TenantManager) DeleteTenant(tenantID string) error <span class="cov8" title="1">{
        // First get tenant info to clean up database file
        _, err := tm.GetTenant(tenantID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("tenant not found: %w", err)
        }</span>
        
        // Delete tenant configuration
        <span class="cov8" title="1">_, err = tm.db.Exec("DELETE FROM tenants WHERE id = ?", tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete tenant config: %w", err)
        }</span>
        
        // TODO: Delete tenant database file
        // os.Remove(tenant.DatabaseURL)
        
        <span class="cov8" title="1">return nil</span>
}

// initTenantDatabase creates the database schema for a new tenant
func (tm *TenantManager) initTenantDatabase(tenant *TenantConfig) error <span class="cov8" title="1">{
        // Create directory if needed
        dbDir := filepath.Dir(tenant.DatabaseURL)
        if err := os.MkdirAll(dbDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create database directory: %w", err)
        }</span>
        
        // Open database connection
        <span class="cov8" title="1">db, err := sql.Open("sqlite", tenant.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open tenant database: %w", err)
        }</span>
        <span class="cov8" title="1">defer db.Close()
        
        // Enable foreign keys and WAL mode for better performance
        pragmas := []string{
                "PRAGMA foreign_keys = ON",
                "PRAGMA journal_mode = WAL",
                "PRAGMA synchronous = NORMAL",
                "PRAGMA cache_size = 10000",
                "PRAGMA temp_store = MEMORY",
        }
        
        for _, pragma := range pragmas </span><span class="cov8" title="1">{
                if _, err := db.Exec(pragma); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set pragma %s: %w", pragma, err)
                }</span>
        }
        
        // Initialize ContextLite schema
        <span class="cov8" title="1">schema := `
        -- Documents table
        CREATE TABLE IF NOT EXISTS documents (
                id TEXT PRIMARY KEY,
                path TEXT NOT NULL,
                content TEXT NOT NULL,
                language TEXT,
                size_bytes INTEGER DEFAULT 0,
                created_at INTEGER DEFAULT (strftime('%s', 'now')),
                updated_at INTEGER DEFAULT (strftime('%s', 'now')),
                tenant_id TEXT NOT NULL
        );
        
        -- FTS5 virtual table for full-text search
        CREATE VIRTUAL TABLE IF NOT EXISTS documents_fts USING fts5(
                content,
                content='documents',
                content_rowid='rowid'
        );
        
        -- Triggers to keep FTS in sync
        CREATE TRIGGER IF NOT EXISTS documents_ai AFTER INSERT ON documents BEGIN
                INSERT INTO documents_fts(rowid, content) VALUES (new.rowid, new.content);
        END;
        
        CREATE TRIGGER IF NOT EXISTS documents_ad AFTER DELETE ON documents BEGIN
                INSERT INTO documents_fts(documents_fts, rowid, content) VALUES('delete', old.rowid, old.content);
        END;
        
        CREATE TRIGGER IF NOT EXISTS documents_au AFTER UPDATE ON documents BEGIN
                INSERT INTO documents_fts(documents_fts, rowid, content) VALUES('delete', old.rowid, old.content);
                INSERT INTO documents_fts(rowid, content) VALUES (new.rowid, new.content);
        END;
        
        -- Cache table for query results
        CREATE TABLE IF NOT EXISTS cache (
                cache_key TEXT PRIMARY KEY,
                query_hash TEXT NOT NULL,
                result_data TEXT NOT NULL,
                created_at INTEGER DEFAULT (strftime('%s', 'now')),
                hit_count INTEGER DEFAULT 0,
                last_hit INTEGER DEFAULT (strftime('%s', 'now')),
                tenant_id TEXT NOT NULL
        );
        
        -- Workspace weights for learning
        CREATE TABLE IF NOT EXISTS workspace_weights (
                workspace_path TEXT PRIMARY KEY,
                relevance_weight REAL DEFAULT 0.3,
                recency_weight REAL DEFAULT 0.2,
                entanglement_weight REAL DEFAULT 0.15,
                diversity_weight REAL DEFAULT 0.15,
                redundancy_penalty REAL DEFAULT 0.2,
                update_count INTEGER DEFAULT 0,
                last_updated TEXT,
                tenant_id TEXT NOT NULL
        );
        
        -- Tenant-specific configuration
        CREATE TABLE IF NOT EXISTS tenant_config (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at INTEGER DEFAULT (strftime('%s', 'now'))
        );
        
        -- Indexes for performance
        CREATE INDEX IF NOT EXISTS idx_documents_path ON documents(path);
        CREATE INDEX IF NOT EXISTS idx_documents_tenant ON documents(tenant_id);
        CREATE INDEX IF NOT EXISTS idx_cache_tenant ON cache(tenant_id);
        CREATE INDEX IF NOT EXISTS idx_cache_created_at ON cache(created_at);
        CREATE INDEX IF NOT EXISTS idx_workspace_weights_tenant ON workspace_weights(tenant_id);
        `
        
        // Execute schema
        if _, err := db.Exec(schema); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize schema: %w", err)
        }</span>
        
        // Insert tenant configuration
        <span class="cov8" title="1">configStmts := []struct {
                key   string
                value interface{}
        }{
                {"tenant_id", tenant.ID},
                {"tenant_name", tenant.Name},
                {"created_at", time.Now().Unix()},
                {"max_documents", tenant.Settings.MaxDocuments},
                {"max_cache_entries", 10000},
                {"cache_ttl_hours", 24},
        }
        
        // Apply tenant-specific settings
        if tenant.Settings.Settings != nil </span><span class="cov0" title="0">{
                for key, value := range tenant.Settings.Settings </span><span class="cov0" title="0">{
                        configStmts = append(configStmts, struct {
                                key   string
                                value interface{}
                        }{key, value})
                }</span>
        }
        
        <span class="cov8" title="1">insertConfigStmt := "INSERT OR REPLACE INTO tenant_config (key, value) VALUES (?, ?)"
        for _, config := range configStmts </span><span class="cov8" title="1">{
                valueStr := fmt.Sprintf("%v", config.value)
                if _, err := db.Exec(insertConfigStmt, config.key, valueStr); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to insert config %s: %w", config.key, err)
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// storeTenantConfig persists tenant configuration to main database
func (tm *TenantManager) storeTenantConfig(tenant *TenantConfig) error <span class="cov8" title="1">{
        query := `
                INSERT INTO tenants (
                        id, name, domain, org_id, database_url, created_at,
                        max_users, max_documents, retention_days, sso_enabled,
                        sso_provider, custom_mcp, analytics
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `
        
        _, err := tm.db.Exec(query,
                tenant.ID, tenant.Name, tenant.Domain, tenant.OrgID,
                tenant.DatabaseURL, tenant.CreatedAt,
                tenant.Settings.MaxUsers, tenant.Settings.MaxDocuments,
                tenant.Settings.RetentionDays, tenant.Settings.SSOEnabled,
                tenant.Settings.SSOProvider, tenant.Settings.CustomMCP,
                tenant.Settings.Analytics,
        )
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store tenant config: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// generateTenantID creates a unique tenant identifier
func generateTenantID() (string, error) <span class="cov8" title="1">{
        bytes := make([]byte, 16)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(bytes), nil</span>
}

// InitTenantSchema creates the tenants table in main database
func InitTenantSchema(db *sql.DB) error <span class="cov8" title="1">{
        schema := `
                CREATE TABLE IF NOT EXISTS tenants (
                        id TEXT PRIMARY KEY,
                        name TEXT NOT NULL,
                        domain TEXT UNIQUE NOT NULL,
                        org_id TEXT NOT NULL,
                        database_url TEXT NOT NULL,
                        created_at DATETIME NOT NULL,
                        max_users INTEGER DEFAULT 100,
                        max_documents INTEGER DEFAULT 1000000,
                        retention_days INTEGER DEFAULT 365,
                        sso_enabled BOOLEAN DEFAULT false,
                        sso_provider TEXT DEFAULT '',
                        custom_mcp BOOLEAN DEFAULT false,
                        analytics BOOLEAN DEFAULT true
                );
                
                CREATE INDEX IF NOT EXISTS idx_tenants_org_id ON tenants(org_id);
                CREATE INDEX IF NOT EXISTS idx_tenants_domain ON tenants(domain);
        `
        
        _, err := db.Exec(schema)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create tenant schema: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
